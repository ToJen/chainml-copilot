{"id": "798034d8625b", "text": "Markets\nGovernance\nDocs\n\u2022Compound II \n\u2022cTokens \n\u2022Comptroller \n\u2022Governance \n\u2022Open Price Feed \n\u2022Security \nCompound v2\ncTokens\nComptroller\nGovernance\nOpen Price Feed\nSecurity\nComptroller\nArchitecture\nEnter Markets\nExit Market\nGet Assets In\nCollateral Factor\nGet Account Liquidity\nClose Factor\nLiquidation Incentive\nKey Events\nError Codes\nCOMP Distribution Speeds\nClaim COMP\nMarket Metadata\nComptroller\nIntroduction\nThe Comptroller is the risk management layer of the Compound \nprotocol; it determines how much collateral a user is required to", "metadata": {"page_number": 1, "source": "data/compound_docs.pdf"}}
{"id": "93f8fcad40b4", "text": "maintain, and whether (and by how much) a user can be liquidated. \nEach time a user interacts with a cToken, the Comptroller is asked to \napprove or deny the transaction.\nThe Comptroller maps user balances to prices (via the Price Oracle) to \nrisk weights (called Collateral Factors) to make its determinations. \nUsers explicitly list which assets they would like included in their risk \nscoring, by calling Enter Markets and Exit Market.\nArchitecture\nThe Comptroller is implemented as an upgradeable proxy. The \nUnitroller proxies all logic to the Comptroller implementation, but \nstorage values are set on the Unitroller. To call Comptroller functions, \nuse the Comptroller ABI on the Unitroller address.\nEnter Markets\nEnter into a list of markets - it is not an error to enter the same market \nmore than once. In order to supply collateral or borrow in a market, it \nmust be entered first.", "metadata": {"page_number": 2, "source": "data/compound_docs.pdf"}}
{"id": "2ab847db647d", "text": "Enter Markets\nEnter into a list of markets - it is not an error to enter the same market \nmore than once. In order to supply collateral or borrow in a market, it \nmust be entered first.\nComptroller\nfunction enterMarkets(address[] calldata cTokens) \nreturns (uint[] memory)\n\u2022msg.sender: The account which shall enter the given markets.\n\u2022cTokens: The addresses of the cToken markets to enter.", "metadata": {"page_number": 2, "source": "data/compound_docs.pdf"}}
{"id": "876a59c50a30", "text": "\u2022RETURN: For each market, returns an error code indicating \nwhether or not it was entered. Each is 0 on success, otherwise \nan Error code.\nSolidity\nComptroller troll = Comptroller(0xABCD...);\nCToken[] memory cTokens = new CToken[](2);\ncTokens[0] = CErc20(0x3FDA...);\ncTokens[1] = CEther(0x3FDB...);\nuint[] memory errors = troll.enterMarkets(cTokens);\nWeb3 1.0\nconst troll = Comptroller.at(0xABCD...);\nconst cTokens = [CErc20.at(0x3FDA...), \nCEther.at(0x3FDB...)];\nconst errors = await", "metadata": {"page_number": 3, "source": "data/compound_docs.pdf"}}
{"id": "210d2577c634", "text": "const cTokens = [CErc20.at(0x3FDA...), \nCEther.at(0x3FDB...)];\nconst errors = await \ntroll.methods.enterMarkets(cTokens).send({from: ...});\nExit Market\nExit a market - it is not an error to exit a market which is not currently \nentered. Exited markets will not count towards account liquidity \ncalculations.\nComptroller\nfunction exitMarket(address cToken) returns (uint)\n\u2022msg.sender: The account which shall exit the given market.\n\u2022cTokens: The addresses of the cToken market to exit.", "metadata": {"page_number": 3, "source": "data/compound_docs.pdf"}}
{"id": "bd70f14332f1", "text": "\u2022RETURN: 0 on success, otherwise an Error code.\nSolidity\nComptroller troll = Comptroller(0xABCD...);\nuint error = troll.exitMarket(CToken(0x3FDA...));\nWeb3 1.0\nconst troll = Comptroller.at(0xABCD...);\nconst errors = await \ntroll.methods.exitMarket(CEther.at(0x3FDB...)).send({f\nrom: ...});\nGet Assets In\nGet the list of markets an account is currently entered into. In order to \nsupply collateral or borrow in a market, it must be entered first. Entered \nmarkets count towards account liquidity calculations.\nComptroller\nfunction getAssetsIn(address account) view returns \n(address[] memory)", "metadata": {"page_number": 4, "source": "data/compound_docs.pdf"}}
{"id": "5bbdafd5b874", "text": "supply collateral or borrow in a market, it must be entered first. Entered \nmarkets count towards account liquidity calculations.\nComptroller\nfunction getAssetsIn(address account) view returns \n(address[] memory)\n\u2022account: The account whose list of entered markets shall be \nqueried.\n\u2022RETURN: The address of each market which is currently entered \ninto.", "metadata": {"page_number": 4, "source": "data/compound_docs.pdf"}}
{"id": "64d0e5f66b9a", "text": "Solidity\nComptroller troll = Comptroller(0xABCD...);\naddress[] memory markets = \ntroll.getAssetsIn(0xMyAccount);\nWeb3 1.0\nconst troll = Comptroller.at(0xABCD...);\nconst markets = await \ntroll.methods.getAssetsIn(cTokens).call();\nCollateral Factor\nA cToken\u2019s collateral factor can range from 0-90%, and represents the \nproportionate increase in liquidity (borrow limit) that an account \nreceives by minting the cToken. Generally, large or liquid assets have \nhigh collateral factors, while small or illiquid assets have low collateral \nfactors. If an asset has a 0% collateral factor, it can\u2019t be used as \ncollateral (or seized in liquidation), though it can still be borrowed.", "metadata": {"page_number": 5, "source": "data/compound_docs.pdf"}}
{"id": "3b9a769e6f20", "text": "high collateral factors, while small or illiquid assets have low collateral \nfactors. If an asset has a 0% collateral factor, it can\u2019t be used as \ncollateral (or seized in liquidation), though it can still be borrowed.\nCollateral factors can be increased (or decreased) through \nCompound Governance, as market conditions change. \nComptroller\nfunction markets(address cTokenAddress) view returns \n(bool, uint, bool)", "metadata": {"page_number": 5, "source": "data/compound_docs.pdf"}}
{"id": "562f76488087", "text": "\u2022cTokenAddress: The address of the cToken to check if listed and \nget the collateral factor for.\n\u2022RETURN: Tuple of values (isListed, collateralFactorMantissa, \nisComped); isListed represents whether the comptroller \nrecognizes this cToken; collateralFactorMantissa, scaled by \n1e18, is multiplied by a supply balance to determine how much \nvalue can be borrowed. The isComped boolean indicates \nwhether or not suppliers and borrowers are distributed COMP \ntokens.\nSolidity\nComptroller troll = Comptroller(0xABCD...);\n(bool isListed, uint collateralFactorMantissa, bool \nisComped) = troll.markets(0x3FDA...);\nWeb3 1.0\nconst troll = Comptroller.at(0xABCD...);", "metadata": {"page_number": 6, "source": "data/compound_docs.pdf"}}
{"id": "86d3f30c2236", "text": "isComped) = troll.markets(0x3FDA...);\nWeb3 1.0\nconst troll = Comptroller.at(0xABCD...);\nconst result = await \ntroll.methods.markets(0x3FDA...).call();\nconst {0: isListed, 1: collateralFactorMantissa, 2: \nisComped} = result;\nGet Account Liquidity\nAccount Liquidity represents the USD value borrowable by a user, \nbefore it reaches liquidation. Users with a shortfall (negative liquidity) \nare subject to liquidation, and can\u2019t withdraw or borrow assets until \nAccount Liquidity is positive again.\nFor each market the user has entered into, their supplied balance is \nmultiplied by the market\u2019s collateral factor, and summed; borrow", "metadata": {"page_number": 6, "source": "data/compound_docs.pdf"}}
{"id": "b7b950134251", "text": "balances are then subtracted, to equal Account Liquidity. Borrowing an \nasset reduces Account Liquidity for each USD borrowed; withdrawing \nan asset reduces Account Liquidity by the asset\u2019s collateral factor \ntimes each USD withdrawn.\nBecause the Compound Protocol exclusively uses unsigned integers, \nAccount Liquidity returns either a surplus or shortfall.\nComptroller\nfunction getAccountLiquidity(address account) view \nreturns (uint, uint, uint)\n\u2022account: The account whose liquidity shall be calculated.\n\u2022RETURN: Tuple of values (error, liquidity, shortfall). The error \nshall be 0 on success, otherwise an error code. A non-zero \nliquidity value indicates the account has available account \nliquidity. A non-zero shortfall value indicates the account is \ncurrently below his/her collateral requirement and is subject to \nliquidation. At most one of liquidity or shortfall shall be non-zero.\nSolidity", "metadata": {"page_number": 7, "source": "data/compound_docs.pdf"}}
{"id": "cf6a6a4b7952", "text": "liquidity. A non-zero shortfall value indicates the account is \ncurrently below his/her collateral requirement and is subject to \nliquidation. At most one of liquidity or shortfall shall be non-zero.\nSolidity\nComptroller troll = Comptroller(0xABCD...);\n(uint error, uint liquidity, uint shortfall) = \ntroll.getAccountLiquidity(msg.caller);\nrequire(error == 0, \"join the Discord\");\nrequire(shortfall == 0, \"account underwater\");\nrequire(liquidity > 0, \"account has excess \ncollateral\");\nWeb3 1.0", "metadata": {"page_number": 7, "source": "data/compound_docs.pdf"}}
{"id": "a8d03208d392", "text": "const troll = Comptroller.at(0xABCD...);\nconst result = await \ntroll.methods.getAccountLiquidity(0xBorrower).call();\nconst {0: error, 1: liquidity, 2: shortfall} = result;\nClose Factor\nThe percent, ranging from 0% to 100%, of a liquidatable account\u2019s \nborrow that can be repaid in a single liquidate transaction. If a user has \nmultiple borrowed assets, the closeFactor applies to any single \nborrowed asset, not the aggregated value of a user\u2019s outstanding \nborrowing.\nComptroller\nfunction closeFactorMantissa() view returns (uint)\n\u2022RETURN: The closeFactor, scaled by 1e18, is multiplied by an \noutstanding borrow balance to determine how much could be \nclosed.\nSolidity", "metadata": {"page_number": 8, "source": "data/compound_docs.pdf"}}
{"id": "7a284656d981", "text": "function closeFactorMantissa() view returns (uint)\n\u2022RETURN: The closeFactor, scaled by 1e18, is multiplied by an \noutstanding borrow balance to determine how much could be \nclosed.\nSolidity\nComptroller troll = Comptroller(0xABCD...);\nuint closeFactor = troll.closeFactorMantissa();\nWeb3 1.0\nconst troll = Comptroller.at(0xABCD...);", "metadata": {"page_number": 8, "source": "data/compound_docs.pdf"}}
{"id": "8fe626bd305d", "text": "const closeFactor = await \ntroll.methods.closeFactorMantissa().call();\nLiquidation Incentive\nThe additional collateral given to liquidators as an incentive to perform \nliquidation of underwater accounts. A portion of this is given to the \ncollateral cToken reserves as determined by the seize share. The \nseize share is assumed to be 0 if the cToken does not have a \nprotocolSeizeShareMantissa constant. For example, if the liquidation \nincentive is 1.08, and the collateral\u2019s seize share is 1.028, liquidators \nreceive an extra 5.2% of the borrower\u2019s collateral for every unit they \nclose, and the remaining 2.8% is added to the cToken\u2019s reserves.\nComptroller\nfunction liquidationIncentiveMantissa() view returns \n(uint)\n\u2022RETURN: The liquidationIncentive, scaled by 1e18, is multiplied", "metadata": {"page_number": 9, "source": "data/compound_docs.pdf"}}
{"id": "63752dab60f6", "text": "Comptroller\nfunction liquidationIncentiveMantissa() view returns \n(uint)\n\u2022RETURN: The liquidationIncentive, scaled by 1e18, is multiplied \nby the closed borrow amount from the liquidator to determine \nhow much collateral can be seized.\nSolidity\nComptroller troll = Comptroller(0xABCD...);\nuint closeFactor = \ntroll.liquidationIncentiveMantissa();\nWeb3 1.0", "metadata": {"page_number": 9, "source": "data/compound_docs.pdf"}}
{"id": "c39a15a3f5a8", "text": "const troll = Comptroller.at(0xABCD...);\nconst closeFactor = await \ntroll.methods.liquidationIncentiveMantissa().call();\nKey Events\nEvent Description\nMarketEntered(CToken \ncToken, address account)Emitted upon a successful \nEnter Market.\nMarketExited(CToken \ncToken, address account)Emitted upon a successful \nExit Market.\nError Codes\nCode Name Description\n0NO_ERROR Not a failure.\n1UNAUTHORIZEDThe sender is not authorized \nto perform this action.\n2COMPTROLLER_MISMATCHLiquidation cannot be \nperformed in markets with \ndifferent comptrollers.", "metadata": {"page_number": 10, "source": "data/compound_docs.pdf"}}
{"id": "92cb6917e63d", "text": "Code Name Description\n3INSUFFICIENT_SHORTFALLThe account does not have \nsufficient shortfall to perform \nthis action.\n4INSUFFICIENT_LIQUIDITYThe account does not have \nsufficient liquidity to perform \nthis action.\n5INVALID_CLOSE_FACTOR The close factor is not valid.\n6INVALID_COLLATERAL_FACTORThe collateral factor is not \nvalid.\n7INVALID_LIQUIDATION_INCENTIV\nEThe liquidation incentive is \ninvalid.\n8MARKET_NOT_ENTEREDThe market has not been \nentered by the account.\n9MARKET_NOT_LISTEDThe market is not currently \nlisted by the comptroller.\n10MARKET_ALREADY_LISTEDAn admin tried to list the same \nmarket more than once.\n11MATH_ERRORA math calculation error \noccurred.", "metadata": {"page_number": 11, "source": "data/compound_docs.pdf"}}
{"id": "68bd25cf9920", "text": "Code Name Description\n12NONZERO_BORROW_BALANCEThe action cannot be \nperformed since the account \ncarries a borrow balance.\n13PRICE_ERRORThe comptroller could not \nobtain a required price of an \nasset.\n14REJECTIONThe comptroller rejects the \naction requested by the \nmarket.\n15SNAPSHOT_ERRORThe comptroller could not get \nthe account borrows and \nexchange rate from the \nmarket.\n16TOO_MANY_ASSETSAttempted to enter more \nmarkets than are currently \nsupported.\n17TOO_MUCH_REPAYAttempted to repay more than \nis allowed by the protocol.\nFailure Info", "metadata": {"page_number": 12, "source": "data/compound_docs.pdf"}}
{"id": "54efb5c1d62f", "text": "Code Name\n0ACCEPT_ADMIN_PENDING_ADMIN_CHECK\n1ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK\n2EXIT_MARKET_BALANCE_OWED\n3EXIT_MARKET_REJECTION\n4SET_CLOSE_FACTOR_OWNER_CHECK\n5SET_CLOSE_FACTOR_VALIDATION\n6SET_COLLATERAL_FACTOR_OWNER_CHECK\n7SET_COLLATERAL_FACTOR_NO_EXISTS\n8SET_COLLATERAL_FACTOR_VALIDATION\n9SET_COLLATERAL_FACTOR_WITHOUT_PRICE\n10SET_IMPLEMENTATION_OWNER_CHECK\n11SET_LIQUIDATION_INCENTIVE_OWNER_CHECK\n12SET_LIQUIDATION_INCENTIVE_VALIDATION\n13SET_MAX_ASSETS_OWNER_CHECK", "metadata": {"page_number": 13, "source": "data/compound_docs.pdf"}}
{"id": "f1a03739bd55", "text": "Code Name\n14SET_PENDING_ADMIN_OWNER_CHECK\n15SET_PENDING_IMPLEMENTATION_OWNER_CHECK\n16SET_PRICE_ORACLE_OWNER_CHECK\n17SUPPORT_MARKET_EXISTS\n18SUPPORT_MARKET_OWNER_CHECK\nCOMP Distribution Speeds\nCOMP Speed\nThe \u201cCOMP speed\u201d unique to each market is an unsigned integer that \nspecifies the amount of COMP that is distributed, per block, to \nsuppliers and borrowers in each market. This number can be changed \nfor individual markets by calling the _setCompSpeed method through a \nsuccessful Compound Governance proposal. The following is the \nformula for calculating the rate that COMP is distributed to each \nsupported market.\nutility = cTokenTotalBorrows * assetPrice\nutilityFraction = utility / \nsumOfAllCOMPedMarketUtilities\nmarketCompSpeed = compRate * utilityFraction", "metadata": {"page_number": 14, "source": "data/compound_docs.pdf"}}
{"id": "d0d623366324", "text": "COMP Distributed Per Block (All Markets)\nThe Comptroller contract\u2019s compRate is an unsigned integer that \nindicates the rate at which the protocol distributes COMP to markets\u2019 \nsuppliers or borrowers, every Ethereum block. The value is the amount \nof COMP (in wei), per block, allocated for the markets. Note that not \nevery market has COMP distributed to its participants (see Market \nMetadata). The compRate indicates how much COMP goes to the \nsuppliers or borrowers, so doubling this number shows how much \nCOMP goes to all suppliers and borrowers combined. The code \nexamples implement reading the amount of COMP distributed, per \nEthereum block, to all markets.\nComptroller\nuint public compRate;\nSolidity\nComptroller troll = Comptroller(0xABCD...);\n// COMP issued per block to suppliers OR borrowers *", "metadata": {"page_number": 15, "source": "data/compound_docs.pdf"}}
{"id": "d3e2a6d4e5fb", "text": "Comptroller\nuint public compRate;\nSolidity\nComptroller troll = Comptroller(0xABCD...);\n// COMP issued per block to suppliers OR borrowers * \n(1 * 10 ^ 18)\nuint compRate = troll.compRate();\n// Approximate COMP issued per day to suppliers OR \nborrowers * (1 * 10 ^ 18)\nuint compRatePerDay = compRate * 4 * 60 * 24;\n// Approximate COMP issued per day to suppliers AND \nborrowers * (1 * 10 ^ 18)\nuint compRatePerDayTotal = compRatePerDay * 2;\nWeb3 1.2.6", "metadata": {"page_number": 15, "source": "data/compound_docs.pdf"}}
{"id": "b47fe6bbefc2", "text": "const comptroller = new \nweb3.eth.Contract(comptrollerAbi, comptrollerAddress);\nlet compRate = await \ncomptroller.methods.compRate().call();\ncompRate = compRate / 1e18;\n// COMP issued to suppliers OR borrowers\nconst compRatePerDay = compRate * 4 * 60 * 24;\n// COMP issued to suppliers AND borrowers\nconst compRatePerDayTotal = compRatePerDay * 2;\nCOMP Distributed Per Block (Single Market)\nThe Comptroller contract has a mapping called compSpeeds. It maps \ncToken addresses to an integer of each market\u2019s COMP distribution \nper Ethereum block. The integer indicates the rate at which the \nprotocol distributes COMP to markets\u2019 suppliers or borrowers. The", "metadata": {"page_number": 16, "source": "data/compound_docs.pdf"}}
{"id": "c2f87275d58e", "text": "cToken addresses to an integer of each market\u2019s COMP distribution \nper Ethereum block. The integer indicates the rate at which the \nprotocol distributes COMP to markets\u2019 suppliers or borrowers. The \nvalue is the amount of COMP (in wei), per block, allocated for the \nmarket. Note that not every market has COMP distributed to its \nparticipants (see Market Metadata). The speed indicates how much \nCOMP goes to the suppliers or the borrowers, so doubling this number \nshows how much COMP goes to market suppliers and borrowers \ncombined. The code examples implement reading the amount of \nCOMP distributed, per Ethereum block, to a single market.\nComptroller\nmapping(address => uint) public compSpeeds;\nSolidity\nComptroller troll = Comptroller(0x123...);\naddress cToken = 0xabc...;", "metadata": {"page_number": 16, "source": "data/compound_docs.pdf"}}
{"id": "2465f4e6a8b1", "text": "// COMP issued per block to suppliers OR borrowers * \n(1 * 10 ^ 18)\nuint compSpeed = troll.compSpeeds(cToken);\n// Approximate COMP issued per day to suppliers OR \nborrowers * (1 * 10 ^ 18)\nuint compSpeedPerDay = compSpeed * 4 * 60 * 24;\n// Approximate COMP issued per day to suppliers AND \nborrowers * (1 * 10 ^ 18)\nuint compSpeedPerDayTotal = compSpeedPerDay * 2;\nWeb3 1.2.6\nconst cTokenAddress = '0xabc...';\nconst comptroller = new \nweb3.eth.Contract(comptrollerAbi, comptrollerAddress);\nlet compSpeed = await \ncomptroller.methods.compSpeeds(cTokenAddress).call();", "metadata": {"page_number": 17, "source": "data/compound_docs.pdf"}}
{"id": "46b4126c80b6", "text": "web3.eth.Contract(comptrollerAbi, comptrollerAddress);\nlet compSpeed = await \ncomptroller.methods.compSpeeds(cTokenAddress).call();\ncompSpeed = compSpeed / 1e18;\n// COMP issued to suppliers OR borrowers\nconst compSpeedPerDay = compSpeed * 4 * 60 * 24;\n// COMP issued to suppliers AND borrowers\nconst compSpeedPerDayTotal = compSpeedPerDay * 2;\nClaim COMP\nEvery Compound user accrues COMP for each block they are \nsupplying to or borrowing from the protocol. Users may call the \nComptroller\u2019s claimComp method at any time to transfer COMP accrued \nto their address.\nComptroller\n// Claim all the COMP accrued by holder in all markets\nfunction claimComp(address holder) public", "metadata": {"page_number": 17, "source": "data/compound_docs.pdf"}}
{"id": "93e3096a3e71", "text": "to their address.\nComptroller\n// Claim all the COMP accrued by holder in all markets\nfunction claimComp(address holder) public\n// Claim all the COMP accrued by holder in specific \nmarkets", "metadata": {"page_number": 17, "source": "data/compound_docs.pdf"}}
{"id": "20e0bd96cb96", "text": "function claimComp(address holder, CToken[] memory \ncTokens) public\n// Claim all the COMP accrued by specific holders in \nspecific markets for their supplies and/or borrows\nfunction claimComp(address[] memory holders, CToken[] \nmemory cTokens, bool borrowers, bool suppliers) public\nSolidity\nComptroller troll = Comptroller(0xABCD...);\ntroll.claimComp(0x1234...);\nWeb3 1.2.6\nconst comptroller = new \nweb3.eth.Contract(comptrollerAbi, comptrollerAddress);\nawait \ncomptroller.methods.claimComp(\"0x1234...\").send({ \nfrom: sender });\nMarket Metadata", "metadata": {"page_number": 18, "source": "data/compound_docs.pdf"}}
{"id": "6a5b02175a97", "text": "await \ncomptroller.methods.claimComp(\"0x1234...\").send({ \nfrom: sender });\nMarket Metadata\nThe Comptroller contract has an array called getAllMarkets that \ncontains the addresses of each cToken contract. Each address in the \ngetAllMarkets array can be used to fetch a metadata struct in the \nComptroller\u2019s markets constant. See the Comptroller Storage contract \nfor the Market struct definition.\nComptroller\nCToken[] public getAllMarkets;", "metadata": {"page_number": 18, "source": "data/compound_docs.pdf"}}
{"id": "3a49976d859e", "text": "Solidity\nComptroller troll = Comptroller(0xABCD...);\nCToken cTokens[] = troll.getAllMarkets();\nWeb3 1.2.6\nconst comptroller = new \nweb3.eth.Contract(comptrollerAbi, comptrollerAddress);\nconst cTokens = await \ncomptroller.methods.getAllMarkets().call();\nconst cToken = cTokens[0]; // address of a cToken\n      \nContract Address", "metadata": {"page_number": 19, "source": "data/compound_docs.pdf"}}
{"id": "d1afc2792d2c", "text": "Markets\nGovernance\nDocs\n\u2022Compound II \n\u2022cTokens \n\u2022Comptroller \n\u2022Governance \n\u2022Open Price Feed \n\u2022Security \nCompound v2\ncTokens\nComptroller\nGovernance\nOpen Price Feed\nSecurity\ncTokens\nMint\nRedeem\nRedeem Underlying\nBorrow\nRepay Borrow\nRepay Borrow Behalf\nTransfer\nLiquidate Borrow\nKey Events\nError Codes\nExchange Rate\nGet Cash\nTotal Borrows\nBorrow Balance\nBorrow Rate\nTotal Supply\nUnderlying Balance\nSupply Rate\nTotal Reserves\nReserve Factor", "metadata": {"page_number": 20, "source": "data/compound_docs.pdf"}}
{"id": "0817dd452c48", "text": "cTokens\nIntroduction\nEach asset supported by the Compound Protocol is integrated through \na cToken contract, which is an EIP-20 compliant representation of \nbalances supplied to the protocol. By minting cTokens, users (1) earn \ninterest through the cToken\u2019s exchange rate, which increases in value \nrelative to the underlying asset, and (2) gain the ability to use cTokens \nas collateral.\ncTokens are the primary means of interacting with the Compound \nProtocol; when a user mints, redeems, borrows, repays a borrow, \nliquidates a borrow, or transfers cTokens, she will do so using the \ncToken contract.\nThere are currently two types of cTokens: CErc20 and CEther. Though \nboth types expose the EIP-20 interface, CErc20 wraps an underlying \nERC-20 asset, while CEther simply wraps Ether itself. As such, the", "metadata": {"page_number": 21, "source": "data/compound_docs.pdf"}}
{"id": "eadec9429ce1", "text": "There are currently two types of cTokens: CErc20 and CEther. Though \nboth types expose the EIP-20 interface, CErc20 wraps an underlying \nERC-20 asset, while CEther simply wraps Ether itself. As such, the \ncore functions which involve transferring an asset into the protocol \nhave slightly different interfaces depending on the type, each of which \nis shown below.\nHow Do cTokens earn interest?\nDo I need to calculate the cToken exchange \nrate?\nCan you walk me through an example?\nHow do I view my cTokens?\nCan I transfer cTokens?\nMint", "metadata": {"page_number": 21, "source": "data/compound_docs.pdf"}}
{"id": "96a13d5bc654", "text": "The mint function transfers an asset into the protocol, which begins \naccumulating interest based on the current Supply Rate for the asset. \nThe user receives a quantity of cTokens equal to the underlying tokens \nsupplied, divided by the current Exchange Rate.\nCErc20\nfunction mint(uint mintAmount) returns (uint)\n\u2022msg.sender: The account which shall supply the asset, and own \nthe minted cTokens.\n\u2022mintAmount: The amount of the asset to be supplied, in units of \nthe underlying asset.\n\u2022RETURN: 0 on success, otherwise an Error code Before \nsupplying an asset, users must first approve the cToken to \naccess their token balance.\nCEther\nfunction mint() payable\n\u2022msg.value: The amount of ether to be supplied, in wei.\n\u2022msg.sender: The account which shall supply the ether, and own", "metadata": {"page_number": 22, "source": "data/compound_docs.pdf"}}
{"id": "ae31460bfd8c", "text": "CEther\nfunction mint() payable\n\u2022msg.value: The amount of ether to be supplied, in wei.\n\u2022msg.sender: The account which shall supply the ether, and own \nthe minted cTokens.\n\u2022RETURN: No return, reverts on error.\nSolidity\nErc20 underlying = Erc20(0xToken...);     // get a \nhandle for the underlying asset contract\nCErc20 cToken = CErc20(0x3FDA...);        // get a \nhandle for the corresponding cToken contract", "metadata": {"page_number": 22, "source": "data/compound_docs.pdf"}}
{"id": "f45db30780f2", "text": "underlying.approve(address(cToken), 100); // approve \nthe transfer\nassert(cToken.mint(100) == 0);            // mint the \ncTokens and assert there is no error\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nawait cToken.methods.mint().send({from: myAccount, \nvalue: 50});\nRedeem\nThe redeem function converts a specified quantity of cTokens into the \nunderlying asset, and returns them to the user. The amount of \nunderlying tokens received is equal to the quantity of cTokens \nredeemed, multiplied by the current Exchange Rate. The amount \nredeemed must be less than the user\u2019s Account Liquidity and the \nmarket\u2019s available liquidity.\nCErc20 / CEther", "metadata": {"page_number": 23, "source": "data/compound_docs.pdf"}}
{"id": "959d34e7cf81", "text": "redeemed, multiplied by the current Exchange Rate. The amount \nredeemed must be less than the user\u2019s Account Liquidity and the \nmarket\u2019s available liquidity.\nCErc20 / CEther\nfunction redeem(uint redeemTokens) returns (uint)\n\u2022msg.sender: The account to which redeemed funds shall be \ntransferred.\n\u2022redeemTokens: The number of cTokens to be redeemed.\n\u2022RETURN: 0 on success, otherwise an Error code\nSolidity", "metadata": {"page_number": 23, "source": "data/compound_docs.pdf"}}
{"id": "fe7e97df57e9", "text": "CEther cToken = CEther(0x3FDB...);\nrequire(cToken.redeem(7) == 0, \"something went \nwrong\");\nWeb3 1.0\nconst cToken = CErc20.at(0x3FDA...);\ncToken.methods.redeem(1).send({from: ...});\nRedeem Underlying\nThe redeem underlying function converts cTokens into a specified \nquantity of the underlying asset, and returns them to the user. The \namount of cTokens redeemed is equal to the quantity of underlying \ntokens received, divided by the current Exchange Rate. The amount \nredeemed must be less than the user\u2019s Account Liquidity and the \nmarket\u2019s available liquidity.\nCErc20 / CEther\nfunction redeemUnderlying(uint redeemAmount) returns", "metadata": {"page_number": 24, "source": "data/compound_docs.pdf"}}
{"id": "351bbc28ba2d", "text": "redeemed must be less than the user\u2019s Account Liquidity and the \nmarket\u2019s available liquidity.\nCErc20 / CEther\nfunction redeemUnderlying(uint redeemAmount) returns \n(uint)\n\u2022msg.sender: The account to which redeemed funds shall be \ntransferred.\n\u2022redeemAmount: The amount of underlying to be redeemed.\n\u2022RETURN: 0 on success, otherwise an Error code\nSolidity", "metadata": {"page_number": 24, "source": "data/compound_docs.pdf"}}
{"id": "4f11b77a674c", "text": "CEther cToken = CEther(0x3FDB...);\nrequire(cToken.redeemUnderlying(50) == 0, \"something \nwent wrong\");\nWeb3 1.0\nconst cToken = CErc20.at(0x3FDA...);\ncToken.methods.redeemUnderlying(10).send({from: ...});\nBorrow\nThe borrow function transfers an asset from the protocol to the user, \nand creates a borrow balance which begins accumulating interest \nbased on the Borrow Rate for the asset. The amount borrowed must \nbe less than the user\u2019s Account Liquidity and the market\u2019s available \nliquidity. To borrow Ether, the borrower must be \u2018payable\u2019 (solidity).\nCErc20 / CEther\nfunction borrow(uint borrowAmount) returns (uint)", "metadata": {"page_number": 25, "source": "data/compound_docs.pdf"}}
{"id": "8252d0b58887", "text": "liquidity. To borrow Ether, the borrower must be \u2018payable\u2019 (solidity).\nCErc20 / CEther\nfunction borrow(uint borrowAmount) returns (uint)\n\u2022msg.sender: The account to which borrowed funds shall be \ntransferred.\n\u2022borrowAmount : The amount of the underlying asset to be \nborrowed.\n\u2022RETURN: 0 on success, otherwise an Error code\nSolidity", "metadata": {"page_number": 25, "source": "data/compound_docs.pdf"}}
{"id": "06bd50ff9666", "text": "CErc20 cToken = CErc20(0x3FDA...);\nrequire(cToken.borrow(100) == 0, \"got collateral?\");\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nawait cToken.methods.borrow(50).send({from: \n0xMyAccount});\nRepay Borrow\nThe repay function transfers an asset into the protocol, reducing the \nuser\u2019s borrow balance.\nCErc20\nfunction repayBorrow(uint repayAmount) returns (uint)\n\u2022msg.sender: The account which borrowed the asset, and shall \nrepay the borrow.\n\u2022repayAmount: The amount of the underlying borrowed asset to \nbe repaid. A value of -1 (i.e. 2^256 - 1) can be used to repay the", "metadata": {"page_number": 26, "source": "data/compound_docs.pdf"}}
{"id": "54c58b3487a1", "text": "repay the borrow.\n\u2022repayAmount: The amount of the underlying borrowed asset to \nbe repaid. A value of -1 (i.e. 2^256 - 1) can be used to repay the \nfull amount.\n\u2022RETURN: 0 on success, otherwise an Error code Before repaying \nan asset, users must first approve the cToken to access their \ntoken balance.\nCEther", "metadata": {"page_number": 26, "source": "data/compound_docs.pdf"}}
{"id": "e900090915ab", "text": "function repayBorrow() payable\n\u2022msg.value: The amount of ether to be repaid, in wei.\n\u2022msg.sender: The account which borrowed the asset, and shall \nrepay the borrow.\n\u2022RETURN: No return, reverts on error.\nSolidity\nCEther cToken = CEther(0x3FDB...);\nrequire(cToken.repayBorrow.value(100)() == 0, \n\"transfer approved?\");\nWeb3 1.0\nconst cToken = CErc20.at(0x3FDA...);\ncToken.methods.repayBorrow(10000).send({from: ...});\nRepay Borrow Behalf\nThe repay function transfers an asset into the protocol, reducing the \ntarget user\u2019s borrow balance.\nCErc20", "metadata": {"page_number": 27, "source": "data/compound_docs.pdf"}}
{"id": "bb112319578f", "text": "Repay Borrow Behalf\nThe repay function transfers an asset into the protocol, reducing the \ntarget user\u2019s borrow balance.\nCErc20\nfunction repayBorrowBehalf(address borrower, uint \nrepayAmount) returns (uint)\n\u2022msg.sender: The account which shall repay the borrow.", "metadata": {"page_number": 27, "source": "data/compound_docs.pdf"}}
{"id": "bc07a2f7c591", "text": "\u2022borrower: The account which borrowed the asset to be repaid.\n\u2022repayAmount: The amount of the underlying borrowed asset to \nbe repaid. A value of -1 (i.e. 2^256 - 1) can be used to repay the \nfull amount.\n\u2022RETURN: 0 on success, otherwise an Error code Before repaying \nan asset, users must first approve the cToken to access their \ntoken balance.\nCEther\nfunction repayBorrowBehalf(address borrower) payable\n\u2022msg.value: The amount of ether to be repaid, in wei.\n\u2022msg.sender: The account which shall repay the borrow.\n\u2022borrower: The account which borrowed the asset to be repaid.\n\u2022RETURN: No return, reverts on error.\nSolidity\nCEther cToken = CEther(0x3FDB...);", "metadata": {"page_number": 28, "source": "data/compound_docs.pdf"}}
{"id": "50de8d7d3900", "text": "\u2022borrower: The account which borrowed the asset to be repaid.\n\u2022RETURN: No return, reverts on error.\nSolidity\nCEther cToken = CEther(0x3FDB...);\nrequire(cToken.repayBorrowBehalf.value(100)(0xBorrower\n) == 0, \"transfer approved?\");\nWeb3 1.0\nconst cToken = CErc20.at(0x3FDA...);\nawait cToken.methods.repayBorrowBehalf(0xBorrower, \n10000).send({from: 0xPayer});\nTransfer", "metadata": {"page_number": 28, "source": "data/compound_docs.pdf"}}
{"id": "ad62e7246279", "text": "Transfer is an ERC-20 method that allows accounts to send tokens to \nother Ethereum addresses. A cToken transfer will fail if the account \nhas entered that cToken market and the transfer would have put the \naccount into a state of negative liquidity.\nCErc20 / CEther\nfunction transfer(address recipient, uint256 amount) \nreturns (bool)\n\u2022recipient: The transfer recipient address.\n\u2022amount: The amount of cTokens to transfer.\n\u2022RETURN: Returns a boolean value indicating whether or not the \noperation succeeded.\nSolidity\nCEther cToken = CEther(0x3FDB...);\ncToken.transfer(0xABCD..., 100000000000);\nWeb3 1.0\nconst cToken = CErc20.at(0x3FDA...);", "metadata": {"page_number": 29, "source": "data/compound_docs.pdf"}}
{"id": "e363de4d0318", "text": "cToken.transfer(0xABCD..., 100000000000);\nWeb3 1.0\nconst cToken = CErc20.at(0x3FDA...);\nawait cToken.methods.transfer(0xABCD..., \n100000000000).send({from: 0xSender});\nLiquidate Borrow\nA user who has negative account liquidity is subject to liquidation by \nother users of the protocol to return his/her account liquidity back to \npositive (i.e. above the collateral requirement). When a liquidation", "metadata": {"page_number": 29, "source": "data/compound_docs.pdf"}}
{"id": "83d17d2972e4", "text": "occurs, a liquidator may repay some or all of an outstanding borrow on \nbehalf of a borrower and in return receive a discounted amount of \ncollateral held by the borrower; this discount is defined as the \nliquidation incentive. A liquidator may close up to a certain fixed \npercentage (i.e. close factor) of any individual outstanding borrow of \nthe underwater account. Unlike in v1, liquidators must interact with \neach cToken contract in which they wish to repay a borrow and seize \nanother asset as collateral. When collateral is seized, the liquidator is \ntransferred cTokens, which they may redeem the same as if they had \nsupplied the asset themselves. Users must approve each cToken \ncontract before calling liquidate (i.e. on the borrowed asset which they \nare repaying), as they are transferring funds into the contract.\nCErc20\nfunction liquidateBorrow(address borrower, uint \namount, address collateral) returns (uint)", "metadata": {"page_number": 30, "source": "data/compound_docs.pdf"}}
{"id": "8af5e9aca712", "text": "are repaying), as they are transferring funds into the contract.\nCErc20\nfunction liquidateBorrow(address borrower, uint \namount, address collateral) returns (uint)\n\u2022msg.sender: The account which shall liquidate the borrower by \nrepaying their debt and seizing their collateral.\n\u2022borrower: The account with negative account liquidity that shall \nbe liquidated.\n\u2022repayAmount: The amount of the borrowed asset to be repaid \nand converted into collateral, specified in units of the underlying \nborrowed asset.\n\u2022cTokenCollateral: The address of the cToken currently held as \ncollateral by a borrower, that the liquidator shall seize.\n\u2022RETURN: 0 on success, otherwise an Error code Before \nsupplying an asset, users must first approve the cToken to \naccess their token balance.\nCEther", "metadata": {"page_number": 30, "source": "data/compound_docs.pdf"}}
{"id": "f6a728ce5e35", "text": "function liquidateBorrow(address borrower, address \ncTokenCollateral) payable\n\u2022msg.value: The amount of ether to be repaid and converted into \ncollateral, in wei.\n\u2022msg.sender: The account which shall liquidate the borrower by \nrepaying their debt and seizing their collateral.\n\u2022borrower: The account with negative account liquidity that shall \nbe liquidated.\n\u2022cTokenCollateral: The address of the cToken currently held as \ncollateral by a borrower, that the liquidator shall seize.\n\u2022RETURN: No return, reverts on error.\nSolidity\nCEther cToken = CEther(0x3FDB...);\nCErc20 cTokenCollateral = CErc20(0x3FDA...);\nrequire(cToken.liquidateBorrow.value(100)(0xBorrower,", "metadata": {"page_number": 31, "source": "data/compound_docs.pdf"}}
{"id": "ffe76a2da3af", "text": "CErc20 cTokenCollateral = CErc20(0x3FDA...);\nrequire(cToken.liquidateBorrow.value(100)(0xBorrower, \ncTokenCollateral) == 0, \"borrower underwater??\");\nWeb3 1.0\nconst cToken = CErc20.at(0x3FDA...);\nconst cTokenCollateral = CEther.at(0x3FDB...);\nawait cToken.methods.liquidateBorrow(0xBorrower, 33, \ncTokenCollateral).send({from: 0xLiquidator});\nKey Events", "metadata": {"page_number": 31, "source": "data/compound_docs.pdf"}}
{"id": "fc9cee2ef159", "text": "Event Description\nMint(address minter, uint \nmintAmount, uint mintTokens)Emitted upon a \nsuccessful \nMint.\nRedeem(address redeemer, uint \nredeemAmount, uint redeemTokens)Emitted upon a \nsuccessful \nRedeem.\nBorrow(address borrower, uint \nborrowAmount, uint accountBorrows, \nuint totalBorrows)Emitted upon a \nsuccessful \nBorrow.\nRepayBorrow(address payer, address \nborrower, uint repayAmount, uint \naccountBorrows, uint totalBorrows)Emitted upon a \nsuccessful \nRepay Borrow.\nLiquidateBorrow(address liquidator, \naddress borrower, uint repayAmount, \naddress cTokenCollateral, uint \nseizeTokens)Emitted upon a", "metadata": {"page_number": 32, "source": "data/compound_docs.pdf"}}
{"id": "2f8a61d15010", "text": "successful \nRepay Borrow.\nLiquidateBorrow(address liquidator, \naddress borrower, uint repayAmount, \naddress cTokenCollateral, uint \nseizeTokens)Emitted upon a \nsuccessful \nLiquidate \nBorrow.\nError Codes\nCode Name Description\n0NO_ERROR Not a failure.", "metadata": {"page_number": 32, "source": "data/compound_docs.pdf"}}
{"id": "c1a89298df4d", "text": "Code Name Description\n1UNAUTHORIZEDThe sender is not authorized \nto perform this action.\n2BAD_INPUTAn invalid argument was \nsupplied by the caller.\n3COMPTROLLER_REJECTIONThe action would violate the \ncomptroller policy.\n4COMPTROLLER_CALCULATION_ERRORAn internal calculation has \nfailed in the comptroller.\n5INTEREST_RATE_MODEL_ERRORThe interest rate model \nreturned an invalid value.\n6INVALID_ACCOUNT_PAIRThe specified combination of \naccounts is invalid.\n7INVALID_CLOSE_AMOUNT_REQUESTEDThe amount to liquidate is \ninvalid.\n8INVALID_COLLATERAL_FACTORThe collateral factor is \ninvalid.\n9MATH_ERRORA math calculation error \noccurred.\n10MARKET_NOT_FRESHInterest has not been \nproperly accrued.", "metadata": {"page_number": 33, "source": "data/compound_docs.pdf"}}
{"id": "850065b6c15f", "text": "Code Name Description\n11MARKET_NOT_LISTEDThe market is not currently \nlisted by its comptroller.\n12TOKEN_INSUFFICIENT_ALLOWANCEERC-20 contract must allow \nMoney Market contract to \ncall transferFrom. The \ncurrent allowance is either 0 \nor less than the requested \nsupply, repayBorrow or \nliquidate amount.\n13TOKEN_INSUFFICIENT_BALANCECaller does not have \nsufficient balance in the \nERC-20 contract to complete \nthe desired action.\n14TOKEN_INSUFFICIENT_CASHThe market does not have a \nsufficient cash balance to \ncomplete the transaction. \nYou may attempt this \ntransaction again later.\n15TOKEN_TRANSFER_IN_FAILEDFailure in ERC-20 when \ntransfering token into the \nmarket.\n16TOKEN_TRANSFER_OUT_FAILEDFailure in ERC-20 when", "metadata": {"page_number": 34, "source": "data/compound_docs.pdf"}}
{"id": "558589e6ef84", "text": "15TOKEN_TRANSFER_IN_FAILEDFailure in ERC-20 when \ntransfering token into the \nmarket.\n16TOKEN_TRANSFER_OUT_FAILEDFailure in ERC-20 when \ntransfering token out of the \nmarket.", "metadata": {"page_number": 34, "source": "data/compound_docs.pdf"}}
{"id": "dc8d88814b36", "text": "Failure Info\nCode Name\n0ACCEPT_ADMIN_PENDING_ADMIN_CHECK\n1ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED\n2ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED\n3ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED\n4ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED\n5ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED\n6ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED\n7BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED\n8BORROW_ACCRUE_INTEREST_FAILED\n9BORROW_CASH_NOT_AVAILABLE\n10BORROW_FRESHNESS_CHECK\n11BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\n12BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED", "metadata": {"page_number": 35, "source": "data/compound_docs.pdf"}}
{"id": "bf5d43a87a27", "text": "Code Name\n13BORROW_MARKET_NOT_LISTED\n14BORROW_COMPTROLLER_REJECTION\n15LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED\n16LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED\n17LIQUIDATE_COLLATERAL_FRESHNESS_CHECK\n18LIQUIDATE_COMPTROLLER_REJECTION\n19LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\n20LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX\n21LIQUIDATE_CLOSE_AMOUNT_IS_ZERO\n22LIQUIDATE_FRESHNESS_CHECK\n23LIQUIDATE_LIQUIDATOR_IS_BORROWER\n24LIQUIDATE_REPAY_BORROW_FRESH_FAILED\n25LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED\n26LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED", "metadata": {"page_number": 36, "source": "data/compound_docs.pdf"}}
{"id": "2d86a03243ad", "text": "Code Name\n27LIQUIDATE_SEIZE_COMPTROLLER_REJECTION\n28LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER\n29LIQUIDATE_SEIZE_TOO_MUCH\n30MINT_ACCRUE_INTEREST_FAILED\n31MINT_COMPTROLLER_REJECTION\n32MINT_EXCHANGE_CALCULATION_FAILED\n33MINT_EXCHANGE_RATE_READ_FAILED\n34MINT_FRESHNESS_CHECK\n35MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\n36MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\n37MINT_TRANSFER_IN_FAILED\n38MINT_TRANSFER_IN_NOT_POSSIBLE\n39REDEEM_ACCRUE_INTEREST_FAILED\n40REDEEM_COMPTROLLER_REJECTION", "metadata": {"page_number": 37, "source": "data/compound_docs.pdf"}}
{"id": "e4c52483979a", "text": "Code Name\n41REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED\n42REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED\n43REDEEM_EXCHANGE_RATE_READ_FAILED\n44REDEEM_FRESHNESS_CHECK\n45REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\n46REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\n47REDEEM_TRANSFER_OUT_NOT_POSSIBLE\n48REDUCE_RESERVES_ACCRUE_INTEREST_FAILED\n49REDUCE_RESERVES_ADMIN_CHECK\n50REDUCE_RESERVES_CASH_NOT_AVAILABLE\n51REDUCE_RESERVES_FRESH_CHECK\n52REDUCE_RESERVES_VALIDATION\n53REPAY_BEHALF_ACCRUE_INTEREST_FAILED\n54REPAY_BORROW_ACCRUE_INTEREST_FAILED", "metadata": {"page_number": 38, "source": "data/compound_docs.pdf"}}
{"id": "ba9bf40b3bb2", "text": "Code Name\n55REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED\n56REPAY_BORROW_COMPTROLLER_REJECTION\n57REPAY_BORROW_FRESHNESS_CHECK\n58REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\n59REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\n60REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE\n61SET_COLLATERAL_FACTOR_OWNER_CHECK\n62SET_COLLATERAL_FACTOR_VALIDATION\n63SET_COMPTROLLER_OWNER_CHECK\n64SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED\n65SET_INTEREST_RATE_MODEL_FRESH_CHECK\n66SET_INTEREST_RATE_MODEL_OWNER_CHECK\n67SET_MAX_ASSETS_OWNER_CHECK\n68SET_ORACLE_MARKET_NOT_LISTED", "metadata": {"page_number": 39, "source": "data/compound_docs.pdf"}}
{"id": "d6f94550fa99", "text": "Code Name\n69SET_PENDING_ADMIN_OWNER_CHECK\n70SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\n71SET_RESERVE_FACTOR_ADMIN_CHECK\n72SET_RESERVE_FACTOR_FRESH_CHECK\n73SET_RESERVE_FACTOR_BOUNDS_CHECK\n74TRANSFER_COMPTROLLER_REJECTION\n75TRANSFER_NOT_ALLOWED\n76TRANSFER_NOT_ENOUGH\n77TRANSFER_TOO_MUCH\nExchange Rate\nEach cToken is convertible into an ever increasing quantity of the \nunderlying asset, as interest accrues in the market. The exchange rate \nbetween a cToken and the underlying asset is equal to:\nexchangeRate = (getCash() + totalBorrows() - \ntotalReserves()) / totalSupply()", "metadata": {"page_number": 40, "source": "data/compound_docs.pdf"}}
{"id": "92b8bab2d9d2", "text": "CErc20 / CEther\nfunction exchangeRateCurrent() returns (uint)\n\u2022RETURN: The current exchange rate as an unsigned integer, \nscaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint exchangeRateMantissa = \ncToken.exchangeRateCurrent();\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst exchangeRate = (await \ncToken.methods.exchangeRateCurrent().call()) / 1e18;\nTip: note the use of call vs. send to invoke the function from off-chain \nwithout incurring gas costs.\nGet Cash\nCash is the amount of underlying balance owned by this cToken", "metadata": {"page_number": 41, "source": "data/compound_docs.pdf"}}
{"id": "3bae71dddddb", "text": "Tip: note the use of call vs. send to invoke the function from off-chain \nwithout incurring gas costs.\nGet Cash\nCash is the amount of underlying balance owned by this cToken \ncontract. One may query the total amount of cash currently available to \nthis market.\nCErc20 / CEther", "metadata": {"page_number": 41, "source": "data/compound_docs.pdf"}}
{"id": "b7609a42e113", "text": "function getCash() returns (uint)\n\u2022RETURN: The quantity of underlying asset owned by the contract.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint cash = cToken.getCash();\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst cash = (await cToken.methods.getCash().call());\nTotal Borrows\nTotal Borrows is the amount of underlying currently loaned out by the \nmarket, and the amount upon which interest is accumulated to \nsuppliers of the market.\nCErc20 / CEther\nfunction totalBorrowsCurrent() returns (uint)\n\u2022RETURN: The total amount of borrowed underlying, with interest.\nSolidity", "metadata": {"page_number": 42, "source": "data/compound_docs.pdf"}}
{"id": "09f2c8e00d89", "text": "CErc20 cToken = CToken(0x3FDA...);\nuint borrows = cToken.totalBorrowsCurrent();\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst borrows = (await \ncToken.methods.totalBorrowsCurrent().call());\nBorrow Balance\nA user who borrows assets from the protocol is subject to accumulated \ninterest based on the current borrow rate. Interest is accumulated \nevery block and integrations may use this function to obtain the current \nvalue of a user\u2019s borrow balance with interest.\nCErc20 / CEther\nfunction borrowBalanceCurrent(address account) returns \n(uint)\n\u2022account: The account which borrowed the assets.\n\u2022RETURN: The user\u2019s current borrow balance (with interest) in", "metadata": {"page_number": 43, "source": "data/compound_docs.pdf"}}
{"id": "5abdc00b3988", "text": "CErc20 / CEther\nfunction borrowBalanceCurrent(address account) returns \n(uint)\n\u2022account: The account which borrowed the assets.\n\u2022RETURN: The user\u2019s current borrow balance (with interest) in \nunits of the underlying asset.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint borrows = \ncToken.borrowBalanceCurrent(msg.caller);", "metadata": {"page_number": 43, "source": "data/compound_docs.pdf"}}
{"id": "7db65be75a48", "text": "Web3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst borrows = await \ncToken.methods.borrowBalanceCurrent(account).call();\nBorrow Rate\nAt any point in time one may query the contract to get the current \nborrow rate per block.\nCErc20 / CEther\nfunction borrowRatePerBlock() returns (uint)\n\u2022RETURN: The current borrow rate as an unsigned integer, scaled \nby 1e18.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint borrowRateMantissa = cToken.borrowRatePerBlock();\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst borrowRate = (await", "metadata": {"page_number": 44, "source": "data/compound_docs.pdf"}}
{"id": "12effe7109ea", "text": "Web3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst borrowRate = (await \ncToken.methods.borrowRatePerBlock().call()) / 1e18;", "metadata": {"page_number": 44, "source": "data/compound_docs.pdf"}}
{"id": "ea7f45cb43e0", "text": "Total Supply\nTotal Supply is the number of tokens currently in circulation in this \ncToken market. It is part of the EIP-20 interface of the cToken contract.\nCErc20 / CEther\nfunction totalSupply() returns (uint)\n\u2022RETURN: The total number of tokens in circulation for the market.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint tokens = cToken.totalSupply();\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst tokens = (await \ncToken.methods.totalSupply().call());\nUnderlying Balance\nThe user\u2019s underlying balance, representing their assets in the \nprotocol, is equal to the user\u2019s cToken balance multiplied by the \nExchange Rate.", "metadata": {"page_number": 45, "source": "data/compound_docs.pdf"}}
{"id": "4d2210b5cfb0", "text": "CErc20 / CEther\nfunction balanceOfUnderlying(address account) returns \n(uint)\n\u2022account: The account to get the underlying balance of.\n\u2022RETURN: The amount of underlying currently owned by the \naccount.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint tokens = cToken.balanceOfUnderlying(msg.caller);\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst tokens = await \ncToken.methods.balanceOfUnderlying(account).call();\nSupply Rate\nAt any point in time one may query the contract to get the current \nsupply rate per block. The supply rate is derived from the borrow rate, \nreserve factor and the amount of total borrows.", "metadata": {"page_number": 46, "source": "data/compound_docs.pdf"}}
{"id": "a18034c8fdce", "text": "Supply Rate\nAt any point in time one may query the contract to get the current \nsupply rate per block. The supply rate is derived from the borrow rate, \nreserve factor and the amount of total borrows.\nCErc20 / CEther", "metadata": {"page_number": 46, "source": "data/compound_docs.pdf"}}
{"id": "077181f5e49a", "text": "function supplyRatePerBlock() returns (uint)\n\u2022RETURN: The current supply rate as an unsigned integer, scaled \nby 1e18.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint supplyRateMantissa = cToken.supplyRatePerBlock();\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst supplyRate = (await \ncToken.methods.supplyRatePerBlock().call()) / 1e18;\nTotal Reserves\nReserves are an accounting entry in each cToken contract that \nrepresents a portion of historical interest set aside as cash which can \nbe withdrawn or transferred through the protocol\u2019s governance. A small \nportion of borrower interest accrues into the protocol, determined by \nthe reserve factor.\nCErc20 / CEther", "metadata": {"page_number": 47, "source": "data/compound_docs.pdf"}}
{"id": "72a388578ed5", "text": "be withdrawn or transferred through the protocol\u2019s governance. A small \nportion of borrower interest accrues into the protocol, determined by \nthe reserve factor.\nCErc20 / CEther\nfunction totalReserves() returns (uint)\n\u2022RETURN: The total amount of reserves held in the market.", "metadata": {"page_number": 47, "source": "data/compound_docs.pdf"}}
{"id": "ae8f3794a067", "text": "Solidity\nCErc20 cToken = CToken(0x3FDA...);\nuint reserves = cToken.totalReserves();\nWeb3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst reserves = (await \ncToken.methods.totalReserves().call());\nReserve Factor\nThe reserve factor defines the portion of borrower interest that is \nconverted into reserves.\nCErc20 / CEther\nfunction reserveFactorMantissa() returns (uint)\n\u2022RETURN: The current reserve factor as an unsigned integer, \nscaled by 1e18.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint reserveFactorMantissa =", "metadata": {"page_number": 48, "source": "data/compound_docs.pdf"}}
{"id": "f2a9dc6e7527", "text": "scaled by 1e18.\nSolidity\nCErc20 cToken = CToken(0x3FDA...);\nuint reserveFactorMantissa = \ncToken.reserveFactorMantissa();", "metadata": {"page_number": 48, "source": "data/compound_docs.pdf"}}
{"id": "2057d98c340a", "text": "Web3 1.0\nconst cToken = CEther.at(0x3FDB...);\nconst reserveFactor = (await \ncToken.methods.reserveFactorMantissa().call()) / 1e18;\n      \nContract Address", "metadata": {"page_number": 49, "source": "data/compound_docs.pdf"}}
{"id": "6f54da91d8fa", "text": "Please enable cookies.\nEmail Protection\nYou are unable to access this email address \ncompound.finance\nThe website from which you got to this page is protected by Cloudflare. Email addresses on that \npage have been hidden in order to keep them from being accessed by malicious bots. You must \nenable Javascript in your browser in order to decode the e-mail address.\nIf you have a website and are interested in protecting it in a similar way, you can sign up for \nCloudflare.\n\u2022How does Cloudflare protect email addresses on website from spammers?\n\u2022Can I sign up for Cloudflare?\nCloudflare Ray ID: 7dc981b1bd4136cf \u2022 Your IP: Click to reveal 216.249.57.2 \u2022 Performance & \nsecurity by Cloudflare", "metadata": {"page_number": 50, "source": "data/compound_docs.pdf"}}
{"id": "4f476d93e712", "text": "Markets\nGovernance\nDocs\n\u2022Compound II \n\u2022cTokens \n\u2022Comptroller \n\u2022Governance \n\u2022Open Price Feed \n\u2022Security \nCompound v2\ncTokens\nComptroller\nGovernance\nOpen Price Feed\nSecurity\nGovernance\nCOMP\nDelegate\nDelegate By Signature\nGet Current Votes\nGet Prior Votes\nKey Events\nGovernor Bravo\nQuorum Votes\nProposal Threshold\nProposal Max Operations\nVoting Delay\nVoting Period\nPropose\nQueue\nExecute\nCancel\nGet Actions\nGet Receipt\nState\nCast Vote\nCast Vote With Reason", "metadata": {"page_number": 51, "source": "data/compound_docs.pdf"}}
{"id": "e39a8294b029", "text": "Cast Vote By Signature\nTimelock\nPause Guardian\nGovernance\nIntroduction\nThe Compound protocol is governed and upgraded by COMP token-\nholders, using three distinct components; the COMP token, \ngovernance module ( Governor Bravo), and Timelock. Together, these \ncontracts allow the community to propose, vote, and implement \nchanges through the administrative functions of a cToken or the \nComptroller. Proposals can modify system parameters, support new \nmarkets, or add entirely new functionality to the protocol.\nCOMP token-holders can delegate their voting rights to themselves, or \nan address of their choice. Addresses delegated at least 25,000 \nCOMP can create governance proposals; any address can lock 100 \nCOMP to create an Autonomous Proposal, which becomes a \ngovernance proposal after being delegated 25,000 COMP.\nWhen a governance proposal is created, it enters a 2 day review \nperiod, after which voting weights are recorded and voting begins.", "metadata": {"page_number": 52, "source": "data/compound_docs.pdf"}}
{"id": "55c8e36d6a30", "text": "COMP to create an Autonomous Proposal, which becomes a \ngovernance proposal after being delegated 25,000 COMP.\nWhen a governance proposal is created, it enters a 2 day review \nperiod, after which voting weights are recorded and voting begins. \nVoting lasts for 3 days; if a majority, and at least 400,000 votes are \ncast for the proposal, it is queued in the Timelock, and can be \nimplemented 2 days later. In total, any change to the protocol takes at \nleast one week. \nCOMP", "metadata": {"page_number": 52, "source": "data/compound_docs.pdf"}}
{"id": "91a49131739d", "text": "COMP is an ERC-20 token that allows the owner to delegate voting \nrights to any address, including their own address. Changes to the \nowner\u2019s token balance automatically adjust the voting rights of the \ndelegate.\nDelegate\nDelegate votes from the sender to the delegatee. Users can delegate \nto 1 address at a time, and the number of votes added to the \ndelegatee\u2019s vote count is equivalent to the balance of COMP in the \nuser\u2019s account. Votes are delegated from the current block and \nonward, until the sender delegates again, or transfers their COMP.\nCOMP\nfunction delegate(address delegatee)\n\u2022delegatee: The address in which the sender wishes to delegate \ntheir votes to.\n\u2022msg.sender: The address of the COMP token holder that is \nattempting to delegate their votes.\n\u2022RETURN: No return, reverts on error.\nSolidity", "metadata": {"page_number": 53, "source": "data/compound_docs.pdf"}}
{"id": "fb1c0cd0c888", "text": "their votes to.\n\u2022msg.sender: The address of the COMP token holder that is \nattempting to delegate their votes.\n\u2022RETURN: No return, reverts on error.\nSolidity\nComp comp = Comp(0x123...); // contract address\ncomp.delegate(delegateeAddress);\nWeb3 1.2.6", "metadata": {"page_number": 53, "source": "data/compound_docs.pdf"}}
{"id": "2af8f7ca5fdb", "text": "const tx = await \ncomp.methods.delegate(delegateeAddress).send({ from: \nsender });\nDelegate By Signature\nDelegate votes from the signatory to the delegatee. This method has \nthe same purpose as Delegate but it instead enables offline signatures \nto participate in Compound governance vote delegation. For more \ndetails on how to create an offline signature, review EIP-712.\nCOMP\nfunction delegateBySig(address delegatee, uint nonce, \nuint expiry, uint8 v, bytes32 r, bytes32 s)\n\u2022delegatee: The address in which the sender wishes to delegate \ntheir votes to.\n\u2022nonce: The contract state required to match the signature. This \ncan be retrieved from the contract\u2019s public nonces mapping.\n\u2022expiry: The time at which to expire the signature. A block", "metadata": {"page_number": 54, "source": "data/compound_docs.pdf"}}
{"id": "1ac292cc253a", "text": "their votes to.\n\u2022nonce: The contract state required to match the signature. This \ncan be retrieved from the contract\u2019s public nonces mapping.\n\u2022expiry: The time at which to expire the signature. A block \ntimestamp as seconds since the unix epoch (uint).\n\u2022v: The recovery byte of the signature.\n\u2022r: Half of the ECDSA signature pair.\n\u2022s: Half of the ECDSA signature pair.\n\u2022RETURN: No return, reverts on error.\nSolidity\nComp comp = Comp(0x123...); // contract address", "metadata": {"page_number": 54, "source": "data/compound_docs.pdf"}}
{"id": "5815486f3cdb", "text": "comp.delegateBySig(delegateeAddress, nonce, expiry, v, \nr, s);\nWeb3 1.2.6\nconst tx = await \ncomp.methods.delegateBySig(delegateeAddress, nonce, \nexpiry, v, r, s).send({});\nGet Current Votes\nGets the balance of votes for an account as of the current block.\nCOMP\nfunction getCurrentVotes(address account) returns \n(uint96)\n\u2022account: Address of the account in which to retrieve the number \nof votes.\n\u2022RETURN: The number of votes (integer).\nSolidity\nComp comp = Comp(0x123...); // contract address\nuint votes = comp.getCurrentVotes(0xabc...);", "metadata": {"page_number": 55, "source": "data/compound_docs.pdf"}}
{"id": "6488a5438212", "text": "Solidity\nComp comp = Comp(0x123...); // contract address\nuint votes = comp.getCurrentVotes(0xabc...);\nWeb3 1.2.6\nconst account = '0x123...'; // contract address", "metadata": {"page_number": 55, "source": "data/compound_docs.pdf"}}
{"id": "e35d3316801a", "text": "const votes = await \ncomp.methods.getCurrentVotes(account).call();\nGet Prior Votes\nGets the prior number of votes for an account at a specific block \nnumber. The block number passed must be a finalized block or the \nfunction will revert.\nCOMP\nfunction getPriorVotes(address account, uint \nblockNumber) returns (uint96)\n\u2022account: Address of the account in which to retrieve the prior \nnumber of votes.\n\u2022blockNumber: The block number at which to retrieve the prior \nnumber of votes.\n\u2022RETURN: The number of prior votes.\nSolidity\nComp comp = Comp(0x123...); // contract address\nuint priorVotes = comp.getPriorVotes(account, \nblockNumber);\nWeb3 1.2.6", "metadata": {"page_number": 56, "source": "data/compound_docs.pdf"}}
{"id": "ebbd0a71a585", "text": "Comp comp = Comp(0x123...); // contract address\nuint priorVotes = comp.getPriorVotes(account, \nblockNumber);\nWeb3 1.2.6\nconst priorVotes = await \ncomp.methods.getPriorVotes(account, \nblockNumber).call();", "metadata": {"page_number": 56, "source": "data/compound_docs.pdf"}}
{"id": "cd5e89112adb", "text": "Key Events\nEvent Description\nDelegateChanged(address indexed \ndelegator, address indexed \nfromDelegate, address indexed \ntoDelegate)An event thats \nemitted when an \naccount changes \nits delegate.\nDelegateVotesChanged(address \nindexed delegate, uint \npreviousBalance, uint newBalance)An event thats \nemitted when a \ndelegate \naccount\u2019s vote \nbalance \nchanges.\nProposalCreated(uint id, address \nproposer, address[] targets, \nuint[] values, string[] \nsignatures, bytes[] calldatas, \nuint startBlock, uint endBlock, \nstring description)An event emitted \nwhen a new \nproposal is \ncreated.\nVoteCast(address voter, uint", "metadata": {"page_number": 57, "source": "data/compound_docs.pdf"}}
{"id": "8f702157539e", "text": "uint startBlock, uint endBlock, \nstring description)An event emitted \nwhen a new \nproposal is \ncreated.\nVoteCast(address voter, uint \nproposalId, bool support, uint \nvotes)An event emitted \nwhen a vote has \nbeen cast on a \nproposal.\nProposalCanceled(uint id)An event emitted \nwhen a proposal", "metadata": {"page_number": 57, "source": "data/compound_docs.pdf"}}
{"id": "354e8eb70613", "text": "Event Description\nhas been \ncanceled.\nProposalQueued(uint id, uint eta)An event emitted \nwhen a proposal \nhas been \nqueued in the \nTimelock.\nProposalExecuted(uint id)An event emitted \nwhen a proposal \nhas been \nexecuted in the \nTimelock.\nGovernor Bravo\nGovernor Bravo is the governance module of the protocol; it allows \naddresses with more than 25,000 COMP to propose changes to the \nprotocol. Addresses that held voting weight, at the start of the \nproposal, invoked through the getpriorvotes function, can submit their \nvotes during a 3 day voting period. If a majority, and at least 400,000 \nvotes are cast for the proposal, it is queued in the Timelock, and can \nbe implemented after 2 days.\nQuorum Votes", "metadata": {"page_number": 58, "source": "data/compound_docs.pdf"}}
{"id": "f2f07223f084", "text": "The required minimum number of votes in support of a proposal for it \nto succeed.\nGovernor Bravo\nfunction quorumVotes() public pure returns (uint)\n\u2022RETURN: The minimum number of votes required for a proposal \nto succeed.\nSolidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nuint quorum = gov.quorumVotes();\nWeb3 1.2.6\nconst quorum = await gov.methods.quorumVotes().call();\nProposal Threshold\nThe minimum number of votes required for an account to create a \nproposal. This can be changed through governance.\nGovernor Bravo\nfunction proposalThreshold() returns (uint)", "metadata": {"page_number": 59, "source": "data/compound_docs.pdf"}}
{"id": "dd8a297ae51c", "text": "\u2022RETURN: The minimum number of votes required for an account \nto create a proposal.\nSolidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nuint threshold = gov.proposalThreshold();\nWeb3 1.2.6\nconst threshold = await \ngov.methods.proposalThreshold().call();\nProposal Max Operations\nThe maximum number of actions that can be included in a proposal. \nActions are functions calls that will be made when a proposal succeeds \nand executes.\nGovernor Bravo\nfunction proposalMaxOperations() returns (uint)\n\u2022RETURN: The maximum number of actions that can be included \nin a proposal.\nSolidity", "metadata": {"page_number": 60, "source": "data/compound_docs.pdf"}}
{"id": "8167e1ec55c2", "text": "GovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nuint operations = gov.proposalMaxOperations();\nWeb3 1.2.6\nconst operations = await \ngov.methods.proposalMaxOperations().call();\nVoting Delay\nThe number of Ethereum blocks to wait before voting on a proposal \nmay begin. This value is added to the current block number when a \nproposal is created. This can be changed through governance.\nGovernor Bravo\nfunction votingDelay() returns (uint)\n\u2022RETURN: Number of blocks to wait before voting on a proposal \nmay begin.\nSolidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nuint blocks = gov.votingDelay();\nWeb3 1.2.6", "metadata": {"page_number": 61, "source": "data/compound_docs.pdf"}}
{"id": "8d7ef9970268", "text": "const blocks = await gov.methods.votingDelay().call();\nVoting Period\nThe duration of voting on a proposal, in Ethereum blocks. This can be \nchanged through governance.\nGovernor Bravo\nfunction votingPeriod() returns (uint)\n\u2022RETURN: The duration of voting on a proposal, in Ethereum \nblocks.\nSolidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nuint blocks = gov.votingPeriod();\nWeb3 1.2.6\nconst blocks = await \ngov.methods.votingPeriod().call();\nPropose", "metadata": {"page_number": 62, "source": "data/compound_docs.pdf"}}
{"id": "c1c3d8233de4", "text": "Create a Proposal to change the protocol. E.g., A proposal can set a \ncToken\u2019s interest rate model or risk parameters on the Comptroller. \nProposals will be voted on by delegated voters. If there is sufficient \nsupport before the voting period ends, the proposal shall be \nautomatically enacted. Enacted proposals are queued and executed in \nthe Compound Timelock contract.\nThe sender must hold more COMP than the current proposal threshold \n(proposalThreshold()) as of the immediately previous block. If the \nthreshold is 25,000 COMP, the sender must have been delegated \nmore than 1% of all COMP in order to create a proposal. The proposal \ncan have up to 10 actions (based on proposalMaxOperations()).\nThe proposer cannot create another proposal if they currently have a \npending or active proposal. It is not possible to queue two identical \nactions in the same block (due to a restriction in the Timelock),", "metadata": {"page_number": 63, "source": "data/compound_docs.pdf"}}
{"id": "bd5d72161000", "text": "The proposer cannot create another proposal if they currently have a \npending or active proposal. It is not possible to queue two identical \nactions in the same block (due to a restriction in the Timelock), \ntherefore actions in a single proposal must be unique, and unique \nproposals that share an identical action must be queued in different \nblocks.\nGovernor Bravo\nfunction propose(address[] memory targets, uint[] \nmemory values, string[] memory signatures, bytes[] \nmemory calldatas, string memory description) returns \n(uint)\n\u2022targets: The ordered list of target addresses for calls to be \nmade during proposal execution. This array must be the same \nlength as all other array parameters in this function.\n\u2022values: The ordered list of values (i.e. msg.value) to be passed \nto the calls made during proposal execution. This array must be \nthe same length as all other array parameters in this function.", "metadata": {"page_number": 63, "source": "data/compound_docs.pdf"}}
{"id": "ec245149dce0", "text": "\u2022signatures: The ordered list of function signatures to be passed \nduring execution. This array must be the same length as all \nother array parameters in this function.\n\u2022calldatas: The ordered list of data to be passed to each \nindividual function call during proposal execution. This array \nmust be the same length as all other array parameters in this \nfunction.\n\u2022description: A human readable description of the proposal and \nthe changes it will enact.\n\u2022RETURN: The ID of the newly created proposal.\nSolidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nuint proposalId = gov.propose(targets, values, \nsignatures, calldatas, description);\nWeb3 1.2.6\nconst tx = gov.methods.propose(targets, values, \nsignatures, calldatas, description).send({ from:", "metadata": {"page_number": 64, "source": "data/compound_docs.pdf"}}
{"id": "5501811bacb8", "text": "signatures, calldatas, description);\nWeb3 1.2.6\nconst tx = gov.methods.propose(targets, values, \nsignatures, calldatas, description).send({ from: \nsender });\nQueue\nAfter a proposal has succeeded, it is moved into the Timelock waiting \nperiod using this function. The waiting period (e.g. 2 days) begins \nwhen this function is called. The queue function can be called by any \nEthereum address.\nGovernor Bravo", "metadata": {"page_number": 64, "source": "data/compound_docs.pdf"}}
{"id": "7e2215a6f877", "text": "function queue(uint proposalId)\n\u2022proposalId: ID of a proposal that has succeeded.\n\u2022RETURN: No return, reverts on error.\nSolidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\ngov.queue(proposalId);\nWeb3 1.2.6\nconst tx = gov.methods.queue(proposalId).send({ from: \nsender });\nExecute\nAfter the Timelock waiting period has elapsed, a proposal can be \nexecuted using this function, which applies the proposal changes to \nthe target contracts. This will invoke each of the actions described in \nthe proposal. The execute function can be called by any Ethereum \naddress. Note: this function is payable, so the Timelock contract can \ninvoke payable functions that were selected in the proposal.\nGovernor Bravo", "metadata": {"page_number": 65, "source": "data/compound_docs.pdf"}}
{"id": "be5a163909af", "text": "the proposal. The execute function can be called by any Ethereum \naddress. Note: this function is payable, so the Timelock contract can \ninvoke payable functions that were selected in the proposal.\nGovernor Bravo\nfunction execute(uint proposalId) payable", "metadata": {"page_number": 65, "source": "data/compound_docs.pdf"}}
{"id": "a64b6fd57689", "text": "\u2022proposalId: ID of a succeeded proposal to execute.\n\u2022RETURN: No return, reverts on error.\nSolidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\ngov.execute(proposalId).value(999).gas(999)();\nWeb3 1.2.6\nconst tx = gov.methods.execute(proposalId).send({ \nfrom: sender, value: 1 });\nCancel\nA proposal is eligible to be cancelled at any time prior to its execution, \nincluding while queued in the Timelock, using this function.\nThe cancel function can be called by the proposal creator, or any \nEthereum address, if the proposal creator fails to maintain more \ndelegated votes than the proposal threshold (e.g. 25,000).\nGovernor Bravo\nfunction cancel(uint proposalId)", "metadata": {"page_number": 66, "source": "data/compound_docs.pdf"}}
{"id": "69f63e042c96", "text": "Ethereum address, if the proposal creator fails to maintain more \ndelegated votes than the proposal threshold (e.g. 25,000).\nGovernor Bravo\nfunction cancel(uint proposalId)\n\u2022proposalId: ID of a proposal to cancel. The proposal cannot \nhave already been executed.\n\u2022RETURN: No return, reverts on error.", "metadata": {"page_number": 66, "source": "data/compound_docs.pdf"}}
{"id": "85fa40e24f45", "text": "Solidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\ngov.cancel(proposalId);\nWeb3 1.2.6\nconst tx = gov.methods.cancel(proposalId).send({ from: \nsender });\nGet Actions\nGets the actions of a selected proposal. Pass a proposal ID and get \nthe targets, values, signatures and calldatas of that proposal.\nGovernor Bravo\nfunction getActions(uint proposalId) returns (uint \nproposalId) public view returns (address[] memory \ntargets, uint[] memory values, string[] memory \nsignatures, bytes[] memory calldatas)\n\u2022proposalId: ID of a proposal in which to get its actions.\n\u2022RETURN: Reverts if the proposal ID is invalid. If successful, the \nfollowing 4 references are returned.", "metadata": {"page_number": 67, "source": "data/compound_docs.pdf"}}
{"id": "4f3447131fba", "text": "signatures, bytes[] memory calldatas)\n\u2022proposalId: ID of a proposal in which to get its actions.\n\u2022RETURN: Reverts if the proposal ID is invalid. If successful, the \nfollowing 4 references are returned. \noArray of addresses of contracts the proposal calls.\noArray of unsigned integers the proposal uses as values.\noArray of strings of the proposal\u2019s signatures.\noArray of calldata bytes of the proposal.", "metadata": {"page_number": 67, "source": "data/compound_docs.pdf"}}
{"id": "8a3fac106d01", "text": "Solidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nuint proposalId = 123;\n(address[] memory targets, uint[] memory values, \nstring[] memory signatures, bytes[] memory calldatas) \n= gov.getActions(proposalId);\nWeb3 1.2.6\nconst {0: targets, 1: values, 2: signatures, 3: \ncalldatas} = \ngov.methods.getActions(proposalId).call();\nGet Receipt\nGets a proposal ballot receipt of the indicated voter.\nGovernor Bravo\nfunction getReceipt(uint proposalId, address voter) \nreturns (Receipt memory)\n\u2022proposalId: ID of the proposal in which to get a voter\u2019s ballot \nreceipt.\n\u2022voter: Address of the account of a proposal voter.", "metadata": {"page_number": 68, "source": "data/compound_docs.pdf"}}
{"id": "ae54acb504b2", "text": "returns (Receipt memory)\n\u2022proposalId: ID of the proposal in which to get a voter\u2019s ballot \nreceipt.\n\u2022voter: Address of the account of a proposal voter.\n\u2022RETURN: Reverts on error. If successful, returns a Receipt struct \nfor the ballot of the voter address.", "metadata": {"page_number": 68, "source": "data/compound_docs.pdf"}}
{"id": "6a517f1f288d", "text": "Solidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nReceipt ballot = gov.getReceipt(proposalId, \nvoterAddress);\nWeb3 1.2.6\nconst proposalId = 11;\nconst voterAddress = '0x123...';\nconst result = await \ngov.methods.getReceipt(proposalId, \nvoterAddress).call();\nconst { hasVoted, support, votes } = result;\nState\nGets the proposal state for the specified proposal. The return value, \nProposalState is an enumerated type defined in the Governor Bravo \ncontract.\nGovernor Bravo\nfunction state(uint proposalId) returns \n(ProposalState)\n\u2022proposalId: ID of a proposal in which to get its state.", "metadata": {"page_number": 69, "source": "data/compound_docs.pdf"}}
{"id": "85c1dbbfb11e", "text": "contract.\nGovernor Bravo\nfunction state(uint proposalId) returns \n(ProposalState)\n\u2022proposalId: ID of a proposal in which to get its state.\n\u2022RETURN: Enumerated type ProposalState. The types are \nPending, Active, Canceled, Defeated, Succeeded, Queued, \nExpired, andExecuted.", "metadata": {"page_number": 69, "source": "data/compound_docs.pdf"}}
{"id": "dbd3161c75b7", "text": "Solidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\nGovernorBravo.ProposalState state = gov.state(123);\nWeb3 1.2.6\nconst proposalStates = ['Pending', 'Active', \n'Canceled', 'Defeated', 'Succeeded', 'Queued', \n'Expired', 'Executed'];\nconst proposalId = 123;\nresult = await gov.methods.state(proposalId).call();\nconst proposalState = proposalStates[result];\nCast Vote\nCast a vote on a proposal. The account\u2019s voting weight is determined \nby the number of votes the account had delegated to it at the time the \nproposal state became active.\nGovernor Bravo\nfunction castVote(uint proposalId, uint8 support)", "metadata": {"page_number": 70, "source": "data/compound_docs.pdf"}}
{"id": "50405dcb723b", "text": "by the number of votes the account had delegated to it at the time the \nproposal state became active.\nGovernor Bravo\nfunction castVote(uint proposalId, uint8 support)\n\u2022proposalId: ID of a proposal in which to cast a vote.\n\u2022support: An integer of 0 for against, 1 for in-favor, and 2 for \nabstain.\n\u2022RETURN: No return, reverts on error.", "metadata": {"page_number": 70, "source": "data/compound_docs.pdf"}}
{"id": "49a1cbfe974f", "text": "Solidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\ngov.castVote(proposalId, 1);\nWeb3 1.2.6\nconst tx = gov.methods.castVote(proposalId, 0).send({ \nfrom: sender });\nCast Vote With Reason\nCast a vote on a proposal with a reason attached to the vote.\nGovernor Bravo\nfunction castVoteWithReason(uint proposalId, uint8 \nsupport, string calldata reason)\n\u2022proposalId: ID of a proposal in which to cast a vote.\n\u2022support: An integer of 0 for against, 1 for in-favor, and 2 for \nabstain.\n\u2022reason: A string containing the voter\u2019s reason for their vote \nselection.\n\u2022RETURN: No return, reverts on error.\nSolidity", "metadata": {"page_number": 71, "source": "data/compound_docs.pdf"}}
{"id": "2d89f34273e4", "text": "GovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\ngov.castVoteWithReason(proposalId, 2, \"I think...\");\nWeb3 1.2.6\nconst tx = gov.methods.castVoteWithReason(proposalId, \n0, \"I think...\").send({ from: sender });\nCast Vote By Signature\nCast a vote on a proposal. The account\u2019s voting weight is determined \nby the number of votes the account had delegated at the time that \nproposal state became active. This method has the same purpose as \nCast Vote but it instead enables offline signatures to participate in \nCompound governance voting. For more details on how to create an \noffline signature, review EIP-712.\nGovernor Bravo\nfunction castVoteBySig(uint proposalId, uint8 support,", "metadata": {"page_number": 72, "source": "data/compound_docs.pdf"}}
{"id": "d1efc860a916", "text": "Compound governance voting. For more details on how to create an \noffline signature, review EIP-712.\nGovernor Bravo\nfunction castVoteBySig(uint proposalId, uint8 support, \nuint8 v, bytes32 r, bytes32 s)\n\u2022proposalId: ID of a proposal in which to cast a vote.\n\u2022support: An integer of 0 for against, 1 for in-favor, and 2 for \nabstain.\n\u2022v: The recovery byte of the signature.\n\u2022r: Half of the ECDSA signature pair.\n\u2022s: Half of the ECDSA signature pair.\n\u2022RETURN: No return, reverts on error.", "metadata": {"page_number": 72, "source": "data/compound_docs.pdf"}}
{"id": "898e7c44999f", "text": "Solidity\nGovernorBravo gov = GovernorBravo(0x123...); // \ncontract address\ngov.castVoteBySig(proposalId, 0, v, r, s);\nWeb3 1.2.6\nconst tx = await gov.methods.castVoteBySig(proposalId, \n1, v, r, s).send({});\nTimelock\nEach protocol contract is controlled by the Timelock contract, which \ncan modify system parameters, logic, and contracts in a \u2018time-delayed, \nopt-out\u2019 upgrade pattern. The Timelock has a hard-coded minimum \ndelay which is the least amount of notice possible for a governance \naction. The Timelock contract queues and executes proposals that \nhave passed a Governance vote.\nPause Guardian\nThe Comptroller contract designates a Pause Guardian address \ncapable of disabling protocol functionality. Used only in the event of an", "metadata": {"page_number": 73, "source": "data/compound_docs.pdf"}}
{"id": "255bcdd7ec03", "text": "have passed a Governance vote.\nPause Guardian\nThe Comptroller contract designates a Pause Guardian address \ncapable of disabling protocol functionality. Used only in the event of an \nunforeseen vulnerability, the Pause Guardian has one and only one \nability: to disable a select set of functions: Mint, Borrow, Transfer, and \nLiquidate. The Pause Guardian cannot unpause an action, nor can it \never prevent users from calling Redeem, or Repay Borrow to close", "metadata": {"page_number": 73, "source": "data/compound_docs.pdf"}}
{"id": "8acc498f11fa", "text": "positions and exit the protocol. COMP token-holders designate the \nPause Guardian address, which is held by the Community Multi-Sig.\n      \nContract Address", "metadata": {"page_number": 74, "source": "data/compound_docs.pdf"}}
{"id": "f2d8a3cb06b9", "text": "Markets\nGovernance\nDocs\n\u2022Compound III \n\u2022Interest Rates \n\u2022Collateral & Borrowing \n\u2022Liquidation \n\u2022Account Management \n\u2022Protocol Rewards \n\u2022Governance \n\u2022Helper Functions \nCompound III\nInterest Rates\nCollateral & Borrowing\nLiquidation\nAccount Management\nProtocol Rewards\nGovernance\nHelper Functions\nGovernance\nSet Comet Factory\nSet Governor\nSet Pause Guardian\nPause Protocol Functionality\nIs Supply Paused\nIs Transfer Paused\nIs Withdraw Paused\nIs Absorb Paused\nIs Buy Paused\nSet Base Token Price Feed\nSet Extension Delegate\nSet Borrow Kink\nSet Borrow Interest Rate Slope (Low)\nSet Borrow Interest Rate Slope (High)\nSet Borrow Interest Rate Slope (Base)\nSet Supply Kink", "metadata": {"page_number": 75, "source": "data/compound_docs.pdf"}}
{"id": "2362b496cbc8", "text": "Set Extension Delegate\nSet Borrow Kink\nSet Borrow Interest Rate Slope (Low)\nSet Borrow Interest Rate Slope (High)\nSet Borrow Interest Rate Slope (Base)\nSet Supply Kink\nSet Supply Interest Rate Slope (Low)\nSet Supply Interest Rate Slope (High)\nSet Supply Interest Rate Slope (Base)", "metadata": {"page_number": 75, "source": "data/compound_docs.pdf"}}
{"id": "c98df6cdf655", "text": "Set Store Front Price Factor\nSet Base Tracking Supply Speed\nSet Base Tracking Borrow Speed\nSet Base Minimum For Rewards\nSet Borrow Minimum\nSet Target Reserves\nAdd a New Asset\nUpdate an Existing Asset\nUpdate Asset Price Feed\nUpdate Borrow Collateral Factor\nUpdate Liquidation Collateral Factor\nUpdate Liquidation Factor\nSet Asset Supply Cap\nERC-20 Approve Manager Address\nTransfer Governor\nWithdraw Reserves\nGovernance\nCompound III is a decentralized protocol that is governed by holders \nand delegates of COMP. Governance allows the community to \npropose, vote, and implement changes through the administrative \nsmart contract functions of the Compound III protocol. For more \ninformation on the Governor and Timelock see the original governance \nsection.\nAll instances of Compound III are controlled by the Timelock contract \nwhich is the same administrator of the Compound v2 protocol. The", "metadata": {"page_number": 76, "source": "data/compound_docs.pdf"}}
{"id": "5fb044788ce3", "text": "information on the Governor and Timelock see the original governance \nsection.\nAll instances of Compound III are controlled by the Timelock contract \nwhich is the same administrator of the Compound v2 protocol. The \ngovernance system has control over each proxy, the Configurator \nimplementation, the Comet factory, and the Comet implementation.\nEach time an immutable parameter is set via governance proposal, a \nnew Comet implementation must be deployed by the Comet factory. If", "metadata": {"page_number": 76, "source": "data/compound_docs.pdf"}}
{"id": "407fda86b990", "text": "the proposal is approved by the community, the proxy will point to the \nnew implementation upon execution.\nTo set specific protocol parameters in a proposal, the Timelock must \ncall all of the relevant set methods on the Configurator contract, \nfollowed by deployAndUpgradeTo on the CometProxyAdmin contract.\nMulti-chain Governance\nThe Compound III protocol can be deployed on any EVM chain. The \ndeployment must have access to on-chain asset prices and \ngovernance messages passed from Ethereum Mainnet. The Timelock \non Mainnet is the administrator of all community sanctioned instances \nof Compound III.\nEach deployment outside of Mainnet needs to have a Bridge Receiver \nand Local Timelock contract on its chain. Governance proposals \nexecuted on Mainnet must be read by the chain\u2019s bridge and published \nto the Bridge Receiver. Local Timelocks have an additional delay \nbefore Comet admin functions can be called via proposal execution.", "metadata": {"page_number": 77, "source": "data/compound_docs.pdf"}}
{"id": "667cd7c8e574", "text": "executed on Mainnet must be read by the chain\u2019s bridge and published \nto the Bridge Receiver. Local Timelocks have an additional delay \nbefore Comet admin functions can be called via proposal execution.\nCompound III instance initializations are logged on-chain using the \nENS text record system. The text record can only be modified by a \nGovernance proposal. It can be viewed at v3-additional-\ngrants.compound-community-licenses.eth when the browser network is \nset to Ethereum Mainnet.\nSet Comet Factory\nThis function sets the official contract address of the Comet factory. \nThe only acceptable caller is the Governor.\nConfigurator", "metadata": {"page_number": 77, "source": "data/compound_docs.pdf"}}
{"id": "8f62d4899afd", "text": "function setFactory(address cometProxy, address \nnewFactory) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newFactory: The address of the new Comet contract factory.\n\u2022RETURN: No return, reverts on error.\nSet Governor\nThis function sets the official contract address of the Compound III \nprotocol Governor for subsequent proposals.\nConfigurator\nfunction setGovernor(address cometProxy, address \nnewGovernor) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newGovernor: The address of the new Compound III Governor.\n\u2022RETURN: No return, reverts on error.\nSet Pause Guardian\nThis function sets the official contract address of the Compound III \nprotocol pause guardian. This address has the power to pause supply,", "metadata": {"page_number": 78, "source": "data/compound_docs.pdf"}}
{"id": "cdaf0eff37b3", "text": "\u2022RETURN: No return, reverts on error.\nSet Pause Guardian\nThis function sets the official contract address of the Compound III \nprotocol pause guardian. This address has the power to pause supply, \ntransfer, withdraw, absorb, and buy collateral operations within \nCompound III.\nCOMP token-holders designate the Pause Guardian address, which is \nheld by the Community Multi-Sig.", "metadata": {"page_number": 78, "source": "data/compound_docs.pdf"}}
{"id": "ba7138d5caa1", "text": "Configurator\nfunction setPauseGuardian(address cometProxy, address \nnewPauseGuardian) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newPauseGuardian: The address of the new pause guardian.\n\u2022RETURN: No return, reverts on error.\nPause Protocol Functionality\nThis function pauses the specified protocol functionality in the event of \nan unforeseen vulnerability. The only addresses that are allowed to call \nthis function are the Governor and the Pause Guardian.\nComet\nfunction pause(\n    bool supplyPaused,\n    bool transferPaused,\n    bool withdrawPaused,\n    bool absorbPaused,\n    bool buyPaused\n) override external\n\u2022supplyPaused: Enables or disables all accounts\u2019 ability to supply \nassets to the protocol.", "metadata": {"page_number": 79, "source": "data/compound_docs.pdf"}}
{"id": "e3bb1c1edccd", "text": "bool withdrawPaused,\n    bool absorbPaused,\n    bool buyPaused\n) override external\n\u2022supplyPaused: Enables or disables all accounts\u2019 ability to supply \nassets to the protocol.\n\u2022transferPaused: Enables or disables all account\u2019s ability to \ntransfer assets within the protocol.\n\u2022withdrawPaused: Enables or disables all account\u2019s ability to \nwithdraw assets from the protocol.\n\u2022absorbPaused: Enables or disables protocol absorptions.", "metadata": {"page_number": 79, "source": "data/compound_docs.pdf"}}
{"id": "0751c6f1a1e3", "text": "\u2022buyPaused: Enables or disables the protocol\u2019s ability to sell \nabsorbed collateral.\n\u2022RETURN: No return, reverts on error.\nIs Supply Paused\nThis function returns a boolean indicating whether or not the protocol \nsupply functionality is presently paused.\nComet\nfunction isSupplyPaused() override public view returns \n(bool)\n\u2022RETURN: A boolean value of whether or not the protocol \nfunctionality is presently paused.\nIs Transfer Paused\nThis function returns a boolean indicating whether or not the protocol \ntransfer functionality is presently paused.\nComet\nfunction isTransferPaused() override public view \nreturns (bool)\n\u2022RETURN: A boolean value of whether or not the protocol \nfunctionality is presently paused.\nIs Withdraw Paused", "metadata": {"page_number": 80, "source": "data/compound_docs.pdf"}}
{"id": "5252f498a6df", "text": "This function returns a boolean indicating whether or not the protocol \nwithdraw functionality is presently paused.\nComet\nfunction isWithdrawPaused() override public view \nreturns (bool)\n\u2022RETURN: A boolean value of whether or not the protocol \nfunctionality is presently paused.\nIs Absorb Paused\nThis function returns a boolean indicating whether or not the protocol \nabsorb functionality is presently paused.\nComet\nfunction isAbsorbPaused() override public view returns \n(bool)\n\u2022RETURN: A boolean value of whether or not the protocol \nfunctionality is presently paused.\nIs Buy Paused\nThis function returns a boolean indicating whether or not the protocol\u2019s \nselling of absorbed collateral functionality is presently paused.\nComet", "metadata": {"page_number": 81, "source": "data/compound_docs.pdf"}}
{"id": "cfdc5cf7707e", "text": "function isBuyPaused() override public view returns \n(bool)\n\u2022RETURN: A boolean value of whether or not the protocol \nfunctionality is presently paused.\nSet Base Token Price Feed\nThis function sets the official contract address of the price feed of the \nprotocol base asset.\nConfigurator\nfunction setBaseTokenPriceFeed(address cometProxy, \naddress newBaseTokenPriceFeed) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newBaseTokenPriceFeed: The address of the new price feed \ncontract.\n\u2022RETURN: No return, reverts on error.\nSet Extension Delegate\nThis function sets the official contract address of the protocol\u2019s Comet \nextension delegate. The methods in CometExt.sol are able to be \ncalled via the same proxy as Comet.sol.", "metadata": {"page_number": 82, "source": "data/compound_docs.pdf"}}
{"id": "c826bc70434f", "text": "Set Extension Delegate\nThis function sets the official contract address of the protocol\u2019s Comet \nextension delegate. The methods in CometExt.sol are able to be \ncalled via the same proxy as Comet.sol.\nConfigurator", "metadata": {"page_number": 82, "source": "data/compound_docs.pdf"}}
{"id": "11af8eddc1f1", "text": "function setExtensionDelegate(address cometProxy, \naddress newExtensionDelegate) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newExtensionDelegate: The address of the new extension \ndelegate contract.\n\u2022RETURN: No return, reverts on error.\nSet Borrow Kink\nThis function sets the borrow interest rate utilization curve kink for the \nCompound III base asset.\nConfigurator\nfunction setBorrowKink(address cometProxy, uint64 \nnewKink) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newKink: The new kink parameter.\n\u2022RETURN: No return, reverts on error.\nSet Borrow Interest Rate Slope (Low)\nThis function sets the borrow interest rate slope low bound in the", "metadata": {"page_number": 83, "source": "data/compound_docs.pdf"}}
{"id": "624171a5a00b", "text": "configuration for.\n\u2022newKink: The new kink parameter.\n\u2022RETURN: No return, reverts on error.\nSet Borrow Interest Rate Slope (Low)\nThis function sets the borrow interest rate slope low bound in the \napproximate amount of seconds in one year.\nConfigurator", "metadata": {"page_number": 83, "source": "data/compound_docs.pdf"}}
{"id": "e7b378249f28", "text": "function setBorrowPerYearInterestRateSlopeLow(address \ncometProxy, uint64 newSlope) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newSlope: The slope low bound as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Borrow Interest Rate Slope (High)\nThis function sets the borrow interest rate slope high bound in the \napproximate amount of seconds in one year.\nConfigurator\nfunction setBorrowPerYearInterestRateSlopeHigh(address \ncometProxy, uint64 newSlope) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newSlope: The slope high bound as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Borrow Interest Rate Slope (Base)", "metadata": {"page_number": 84, "source": "data/compound_docs.pdf"}}
{"id": "a5849b9a8c3e", "text": "configuration for.\n\u2022newSlope: The slope high bound as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Borrow Interest Rate Slope (Base)\nThis function sets the borrow interest rate slope base in the \napproximate amount of seconds in one year.\nConfigurator", "metadata": {"page_number": 84, "source": "data/compound_docs.pdf"}}
{"id": "96cacd61ddec", "text": "function setBorrowPerYearInterestRateBase(address \ncometProxy, uint64 newBase) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newSlope: The slope base as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Supply Kink\nThis function sets the supply interest rate utilization curve kink for the \nCompound III base asset.\nConfigurator\nfunction setSupplyKink(address cometProxy, uint64 \nnewKink) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newKink: The new kink parameter.\n\u2022RETURN: No return, reverts on error.\nSet Supply Interest Rate Slope (Low)\nThis function sets the supply interest rate slope low bound in the \napproximate amount of seconds in one year.", "metadata": {"page_number": 85, "source": "data/compound_docs.pdf"}}
{"id": "a6390aa0638b", "text": "\u2022RETURN: No return, reverts on error.\nSet Supply Interest Rate Slope (Low)\nThis function sets the supply interest rate slope low bound in the \napproximate amount of seconds in one year.\nConfigurator", "metadata": {"page_number": 85, "source": "data/compound_docs.pdf"}}
{"id": "7e7450c7c1d2", "text": "function setSupplyPerYearInterestRateSlopeLow(address \ncometProxy, uint64 newSlope) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newSlope: The slope low bound as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Supply Interest Rate Slope (High)\nThis function sets the supply interest rate slope high bound in the \napproximate amount of seconds in one year.\nConfigurator\nfunction setSupplyPerYearInterestRateSlopeHigh(address \ncometProxy, uint64 newSlope) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newSlope: The slope high bound as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Supply Interest Rate Slope (Base)", "metadata": {"page_number": 86, "source": "data/compound_docs.pdf"}}
{"id": "280d0956dce2", "text": "configuration for.\n\u2022newSlope: The slope high bound as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Supply Interest Rate Slope (Base)\nThis function sets the supply interest rate slope base in the \napproximate amount of seconds in one year.\nConfigurator", "metadata": {"page_number": 86, "source": "data/compound_docs.pdf"}}
{"id": "a724895c183b", "text": "function setSupplyPerYearInterestRateBase(address \ncometProxy, uint64 newBase) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newSlope: The slope base as an unsigned integer.\n\u2022RETURN: No return, reverts on error.\nSet Store Front Price Factor\nThis function sets the fraction of the liquidation penalty that goes to \nbuyers of collateral instead of the protocol. This factor is used to \ncalculate the discount rate of collateral for sale as part of the account \nabsorption process. The rate is a decimal scaled up by 10 ^ 18.\nConfigurator\nfunction setStoreFrontPriceFactor(address cometProxy, \nuint64 newStoreFrontPriceFactor) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newStoreFrontPriceFactor: The new price factor as an", "metadata": {"page_number": 87, "source": "data/compound_docs.pdf"}}
{"id": "e939921bb98c", "text": "uint64 newStoreFrontPriceFactor) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newStoreFrontPriceFactor: The new price factor as an \nunsigned integer expressed as a decimal scaled up by 10 ^ 18.\n\u2022RETURN: No return, reverts on error.\nSet Base Tracking Supply Speed\nThis function sets the rate at which base asset supplier accounts \naccrue rewards.", "metadata": {"page_number": 87, "source": "data/compound_docs.pdf"}}
{"id": "61b8386ed3a2", "text": "Configurator\nfunction setBaseTrackingSupplySpeed(address \ncometProxy, uint64 newBaseTrackingSupplySpeed) \nexternal\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newBaseTrackingSupplySpeed: The rate as an APR expressed as \na decimal scaled up by 10 ^ 18.\n\u2022RETURN: No return, reverts on error.\nSet Base Tracking Borrow Speed\nThis function sets the rate at which base asset borrower accounts \naccrue rewards.\nConfigurator\nfunction setBaseTrackingBorrowSpeed(address \ncometProxy, uint64 newBaseTrackingBorrowSpeed) \nexternal\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newBaseTrackingBorrowSpeed: The rate as an APR expressed as", "metadata": {"page_number": 88, "source": "data/compound_docs.pdf"}}
{"id": "ff0bab6b193f", "text": "external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newBaseTrackingBorrowSpeed: The rate as an APR expressed as \na decimal scaled up by 10 ^ 18.\n\u2022RETURN: No return, reverts on error.\nSet Base Minimum For Rewards", "metadata": {"page_number": 88, "source": "data/compound_docs.pdf"}}
{"id": "b9d1eb3a7aff", "text": "This function sets the minimum amount of base asset supplied to the \nprotocol in order for accounts to accrue rewards.\nConfigurator\nfunction setBaseMinForRewards(address cometProxy, \nuint104 newBaseMinForRewards) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newBaseMinForRewards: The amount of base asset scaled up by \n10 to the \u201cdecimals\u201d integer in the base asset\u2019s contract.\n\u2022RETURN: No return, reverts on error.\nSet Borrow Minimum\nThis function sets the minimum amount of base token that is allowed to \nbe borrowed.\nConfigurator\nfunction setBaseBorrowMin(address cometProxy, uint104 \nnewBaseBorrowMin) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.", "metadata": {"page_number": 89, "source": "data/compound_docs.pdf"}}
{"id": "c6134d34e9fb", "text": "Configurator\nfunction setBaseBorrowMin(address cometProxy, uint104 \nnewBaseBorrowMin) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022setBaseBorrowMin: The minimum borrow as an unsigned integer \nscaled up by 10 to the \u201cdecimals\u201d integer in the base asset\u2019s \ncontract.\n\u2022RETURN: No return, reverts on error.\nSet Target Reserves", "metadata": {"page_number": 89, "source": "data/compound_docs.pdf"}}
{"id": "e36595f450b3", "text": "This function sets the target reserves amount. Once the protocol \nreaches this amount of reserves of base asset, liquidators cannot buy \ncollateral from the protocol.\nConfigurator\nfunction setTargetReserves(address cometProxy, uint104 \nnewTargetReserves) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newTargetReserves: The amount of reserves of base asset as \nan unsigned integer scaled up by 10 to the \u201cdecimals\u201d integer in \nthe base asset\u2019s contract.\n\u2022RETURN: No return, reverts on error.\nAdd a New Asset\nThis function adds an asset to the protocol through governance.\nConfigurator\nfunction addAsset(address cometProxy, AssetConfig \ncalldata assetConfig) external\n\u2022cometProxy: The address of the Comet proxy to set the", "metadata": {"page_number": 90, "source": "data/compound_docs.pdf"}}
{"id": "138a59569235", "text": "Configurator\nfunction addAsset(address cometProxy, AssetConfig \ncalldata assetConfig) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022assetConfig: The configuration that is added to the array of \nprotocol asset configurations.\n\u2022RETURN: No return, reverts on error.\nUpdate an Existing Asset", "metadata": {"page_number": 90, "source": "data/compound_docs.pdf"}}
{"id": "baf9e0ad6110", "text": "This function modifies an existing asset\u2019s configuration parameters.\nConfigurator\nfunction updateAsset(address cometProxy, AssetConfig \ncalldata newAssetConfig) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022newAssetConfig: The configuration that is modified in the array \nof protocol asset configurations. All parameters are overwritten.\n\u2022RETURN: No return, reverts on error.\nUpdate Asset Price Feed\nThis function updates the price feed contract address for a specific \nasset.\nConfigurator\nfunction updateAssetPriceFeed(address cometProxy, \naddress asset, address newPriceFeed) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022asset: The address of the underlying asset smart contract.", "metadata": {"page_number": 91, "source": "data/compound_docs.pdf"}}
{"id": "1a8f9b7fae82", "text": "address asset, address newPriceFeed) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022asset: The address of the underlying asset smart contract.\n\u2022newPriceFeed: The address of the new price feed smart \ncontract.\n\u2022RETURN: No return, reverts on error.\nUpdate Borrow Collateral Factor", "metadata": {"page_number": 91, "source": "data/compound_docs.pdf"}}
{"id": "5672690d3cc5", "text": "This function updates the borrow collateral factor for an asset in the \nprotocol.\nConfigurator\nfunction updateAssetBorrowCollateralFactor(address \ncometProxy, address asset, uint64 newBorrowCF) \nexternal\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022asset: The address of the underlying asset smart contract.\n\u2022newBorrowCF: The collateral factor as an integer that represents \nthe decimal value scaled up by 10 ^ 18.\n\u2022RETURN: No return, reverts on error.\nUpdate Liquidation Collateral Factor\nThis function updates the liquidation collateral factor for an asset in the \nprotocol.\nConfigurator\nfunction updateAssetLiquidateCollateralFactor(address \ncometProxy, address asset, uint64 newLiquidateCF) \nexternal", "metadata": {"page_number": 92, "source": "data/compound_docs.pdf"}}
{"id": "a2de90d67dc7", "text": "protocol.\nConfigurator\nfunction updateAssetLiquidateCollateralFactor(address \ncometProxy, address asset, uint64 newLiquidateCF) \nexternal\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022asset: The address of the underlying asset smart contract.\n\u2022newLiquidateCF: The collateral factor as an integer that \nrepresents the decimal value scaled up by 10 ^ 18.\n\u2022RETURN: No return, reverts on error.", "metadata": {"page_number": 92, "source": "data/compound_docs.pdf"}}
{"id": "f5d5526c276d", "text": "Update Liquidation Factor\nThis function updates the liquidation factor for an asset in the protocol.\nThe liquidation factor is a decimal value that is between 0 and 1 \n(inclusive) which determines the amount that is paid out to an \nunderwater account upon liquidation.\nThe following is an example of the liquidation factor\u2019s role in a \nCompound III liquidation:\nAn underwater account has supplied $100 of WBTC as collateral. If the \nWBTC liquidation factor is 0.9, the user will receive $90 of the base \nasset when a liquidator triggers an absorption of their account.\nConfigurator\nfunction updateAssetLiquidationFactor(address \ncometProxy, address asset, uint64 \nnewLiquidationFactor) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022asset: The address of the underlying asset smart contract.", "metadata": {"page_number": 93, "source": "data/compound_docs.pdf"}}
{"id": "c1916f510193", "text": "newLiquidationFactor) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022asset: The address of the underlying asset smart contract.\n\u2022newLiquidationFactor: The factor as an integer that represents \nthe decimal value scaled up by 10 ^ 18.\n\u2022RETURN: No return, reverts on error.\nSet Asset Supply Cap", "metadata": {"page_number": 93, "source": "data/compound_docs.pdf"}}
{"id": "d56b481fdcf5", "text": "This function sets the maximum amount of an asset that can be \nsupplied to the protocol. Supply transactions will revert if the total \nsupply would be greater than this number as a result.\nConfigurator\nfunction updateAssetSupplyCap(address cometProxy, \naddress asset, uint128 newSupplyCap) external\n\u2022cometProxy: The address of the Comet proxy to set the \nconfiguration for.\n\u2022asset: The address of the underlying asset smart contract.\n\u2022newSupplyCap: The amount of the asset as an unsigned integer \nscaled up by 10 to the \u201cdecimals\u201d integer in the asset\u2019s contract.\n\u2022RETURN: No return, reverts on error.\nERC-20 Approve Manager Address\nThis function sets the Comet contract\u2019s ERC-20 allowance of an asset \nfor a manager address. It can only be called by the Governor.\nIn the event of a governance attack, an attacker could create a", "metadata": {"page_number": 94, "source": "data/compound_docs.pdf"}}
{"id": "e888eb529ce3", "text": "ERC-20 Approve Manager Address\nThis function sets the Comet contract\u2019s ERC-20 allowance of an asset \nfor a manager address. It can only be called by the Governor.\nIn the event of a governance attack, an attacker could create a \nproposal that leverages this function to give themselves permissions to \nfreely transfer all ERC-20 tokens out of the Comet contract.\nHypothetically, the attacker would need to either acquire supreme \nvoting weight or add a malicious step in an otherwise innocuous and \npopular proposal and the community would fail to detect before \napproving.\nComet", "metadata": {"page_number": 94, "source": "data/compound_docs.pdf"}}
{"id": "700e12d4b40d", "text": "function approveThis(address manager, address asset, \nuint amount) override external\n\u2022manager: The address of a manager account that has its \nallowance modified.\n\u2022asset: The address of the asset\u2019s smart contract.\n\u2022amount: The amount of the asset approved for the manager \nexpressed as an integer.\n\u2022RETURN: No return, reverts on error.\nTransfer Governor\nThis function changes the address of the Configurator\u2019s Governor.\nConfigurator\nfunction transferGovernor(address newGovernor) \nexternal\n\u2022newGovernor: The address of the new Governor for \nConfigurator.\n\u2022RETURN: No return, reverts on error.\nWithdraw Reserves\nThis function allows governance to withdraw base token reserves from \nthe protocol and send them to a specified address. Only the Governor \naddress may call this function.\nComet", "metadata": {"page_number": 95, "source": "data/compound_docs.pdf"}}
{"id": "0d48cb0580c5", "text": "function withdrawReserves(address to, uint amount) \nexternal\n\u2022to: The address of the recipient of the base asset tokens.\n\u2022amount: The amount of the base asset to send scaled up by 10 \nto the \u201cdecimals\u201d integer in the base asset\u2019s contract.\n\u2022RETURN: No return, reverts on error.\n      \nContract Address", "metadata": {"page_number": 96, "source": "data/compound_docs.pdf"}}
