{"id": "cf2cfe1ef86b", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 1/13\u26a0  DraftStandards Track: ERC\nERC-6551: Non-fungible Token Bound\nAccounts \nAn interface and registry for smart contract accounts owned\nby ERC-721 tokens\nAuthors Jayden Windle\u00a0(@jaydenwindle), Benny Giang\u00a0<bg@futureprimitive.xyz>,\nSteve Jang, Druzy Downs\u00a0(@druzydowns), Raymond Huynh\u00a0(@huynhr),\nAlanah Lam\u00a0<alanah@futureprimitive.xyz>, Wilkins Chung\n(@wwhchung)\u00a0<wilkins@manifold.xyz>, Paul Sullivan\n(@sullivph)\u00a0<paul.sullivan@manifold.xyz>\nCreated2023-02-23", "metadata": {"page_number": 1, "source": "data/erc6551_docs.pdf"}}
{"id": "fb96fe82e2c5", "text": "(@wwhchung)\u00a0<wilkins@manifold.xyz>, Paul Sullivan\n(@sullivph)\u00a0<paul.sullivan@manifold.xyz>\nCreated2023-02-23\nDiscussion Linkhttps://ethereum-magicians.org/t/non-fungible-token-bound-\naccounts/13030\nRequires EIP-155, EIP-165, EIP-721, EIP-1167, EIP-1271\nTable of Contents\nAbstract\nMotivation\nSpecification\nOverview\nRegistry\nAccount Interface\nRationale\nCounterfactual Account Addresses\nAccount Ambiguity\nProxy Implementation\nEIP-155 Support\nBackwards Compatibility\nReference Implementation\nExample Account Implementation\nRegistry Implementation\nSecurity Considerations\nFraud Prevention", "metadata": {"page_number": 1, "source": "data/erc6551_docs.pdf"}}
{"id": "155f7c4ffa3c", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 2/13Ownership Cycles\nCopyright\n Abstract\nThis proposal defines a system which gives every ERC-721 token a smart contract account.\nThese token bound accounts allow ERC-721 tokens to own assets and interact with\napplications, without requiring changes to existing ERC-721 smart contracts or infrastructure.\n Motivation\nThe ERC-721 standard enabled an explosion of non-fungible token applications. Some notable\nuse cases have included breedable cats, generative artwork, and liquidity positions.\nNon-fungible tokens are increasingly becoming a form of on-chain identity. This follows quite\nnaturally from the ERC-721 specification - each non-fungible token has a globally unique\nidentifier, and by extension, a unique identity.", "metadata": {"page_number": 2, "source": "data/erc6551_docs.pdf"}}
{"id": "c4c5de88530f", "text": "Non-fungible tokens are increasingly becoming a form of on-chain identity. This follows quite\nnaturally from the ERC-721 specification - each non-fungible token has a globally unique\nidentifier, and by extension, a unique identity.\nUnlike other forms of on-chain identity, ERC-721 tokens cannot act as an agent or associate\nwith other on-chain assets. This limitation stands in contrast with many real-world instances\nof non-fungible assets. For example:\nA character in a role-playing game that accumulates assets and abilities over time\nbased on actions they have taken\nAn automobile composed of many fungible and non-fungible components\nAn automated investment portfolio composed of multiple fungible assets\nA punch pass membership card granting access to an establishment and recording a\nhistory of past interactions\nSeveral proposals have attempted to give ERC-721 tokens the ability to own assets. Each of", "metadata": {"page_number": 2, "source": "data/erc6551_docs.pdf"}}
{"id": "25cb17171ec5", "text": "An automated investment portfolio composed of multiple fungible assets\nA punch pass membership card granting access to an establishment and recording a\nhistory of past interactions\nSeveral proposals have attempted to give ERC-721 tokens the ability to own assets. Each of\nthese proposals have defined an extension to the ERC-721 standard. This requires smart\ncontract authors to include proposal support in their ERC-721 token contracts. As a result,\nthese proposals are largely incompatible with previously deployed ERC-721 contracts.\nThis proposal grants every ERC-721 token the full capabilities of an Ethereum account while\nmaintaining backwards compatibility with previously deployed ERC-721 token contracts. It\ndoes so by deploying unique, deterministically-addressed smart contract accounts for each\nERC-721 token via a permissionless registry.\nEach token bound account is owned by a single ERC-721 token, allowing the token to interact\nwith the blockchain, record transaction history, and own on-chain assets. Control of each", "metadata": {"page_number": 2, "source": "data/erc6551_docs.pdf"}}
{"id": "b34acefa4a62", "text": "ERC-721 token via a permissionless registry.\nEach token bound account is owned by a single ERC-721 token, allowing the token to interact\nwith the blockchain, record transaction history, and own on-chain assets. Control of each\ntoken bound account is delegated to the owner of the ERC-721 token, allowing the owner to\ninitiate on-chain actions on behalf of their token.", "metadata": {"page_number": 2, "source": "data/erc6551_docs.pdf"}}
{"id": "b51351e63588", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 3/13Token bound accounts are compatible out of the box with nearly all existing infrastructure that\nsupports Ethereum accounts, from on-chain protocols to off-chain indexers. Token bound\naccounts can own any type of on-chain asset, and can be extended to support new asset\ntypes created in the future.\n Specification\nThe key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d,\n\u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this\ndocument are to be interpreted as described in RFC 2119 and RFC 8174.\n Overview\nThe system outlined in this proposal has two main components:\nA permissionless registry for deploying token bound accounts", "metadata": {"page_number": 3, "source": "data/erc6551_docs.pdf"}}
{"id": "ecbecb78eeff", "text": "document are to be interpreted as described in RFC 2119 and RFC 8174.\n Overview\nThe system outlined in this proposal has two main components:\nA permissionless registry for deploying token bound accounts\nA standard interface for token bound account implementations\nThe following diagram illustrates the relationship between ERC-721 tokens, ERC-721 token\nowners, token bound accounts, and the Registry:\n Registry\nThe registry serves as a single entry point for projects wishing to utilize token bound\naccounts. It has two functions:", "metadata": {"page_number": 3, "source": "data/erc6551_docs.pdf"}}
{"id": "a4711cfb9e17", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 4/13createAccount  - deploys a token bound account for an ERC-721 token given an\nimplementation  address\naccount - a read-only function that computes the token bound account address for\nan ERC-721 token given an implementation  address\nThe registry SHALL deploy each token bound account as an ERC-1167 minimal proxy with\nimmutable constant data appended to the bytecode.\nThe the deployed bytecode of each token bound account SHALL have the following structure:\nERC-1167 Header               (10 bytes)\n<implementation (address)>    (20 bytes)\nERC-1167 Footer               (15 bytes)\n<salt (uint256)>              (32 bytes)\n<chainId (uint256)>           (32 bytes)", "metadata": {"page_number": 4, "source": "data/erc6551_docs.pdf"}}
{"id": "8549e6b5ff6e", "text": "<implementation (address)>    (20 bytes)\nERC-1167 Footer               (15 bytes)\n<salt (uint256)>              (32 bytes)\n<chainId (uint256)>           (32 bytes)\n<tokenContract (address)>     (32 bytes)\n<tokenId (uint256)>           (32 bytes)\nFor example, the token bound account with implementation address\n0xbebebebebebebebebebebebebebebebebebebebe , salt 0, chain ID 1, token contract\n0xcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcfcf  and token ID 123 would have the\nfollowing deployed bytecode:\n363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d9160", "metadata": {"page_number": 4, "source": "data/erc6551_docs.pdf"}}
{"id": "3097b77a6da1", "text": "following deployed bytecode:\n363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d9160\nEach token bound account proxy SHALL delegate execution to a contract that implements the\nIERC6551Account  interface.\nThe registry contract is permissionless, immutable, and has no owner. The complete source\ncode for the registry can be found in the Registry Implementation section below. The registry\nSHALL be deployed at address TBD using Nick\u02bcs Factory\n(0x4e59b44847b379578588920cA78FbF26c0B4956C ) with salt\n0x6551655165516551655165516551655165516551655165516551655165516551 .\nThe registry SHALL deploy all token bound account contracts using the create2 opcode so", "metadata": {"page_number": 4, "source": "data/erc6551_docs.pdf"}}
{"id": "b806fc1f7ad7", "text": "0x6551655165516551655165516551655165516551655165516551655165516551 .\nThe registry SHALL deploy all token bound account contracts using the create2 opcode so\nthat the account address for every ERC-721 token is deterministic. The account address for\neach ERC-721 token SHALL be derived from the unique combination of implementation\naddress, token contract address, token ID, EIP-155 chain ID, and an optional salt.\nThe registry SHALL implement the following interface:\ninterface  IERC6551Registry  {\n    /// @dev The registry SHALL emit the AccountCreated event upon successful ac", "metadata": {"page_number": 4, "source": "data/erc6551_docs.pdf"}}
{"id": "240f54b2a23a", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 5/13    event AccountCreated (\n        address account,\n        address implementation ,\n        uint256 chainId,\n        address tokenContract ,\n        uint256 tokenId,\n        uint256 salt\n    );\n    /// @dev Creates a token bound account for an ERC-721 token.\n    ///\n    /// If account has already been created, returns the account address without\n    ///\n    /// If initData is not empty and account has not yet been created, calls acc\n    /// provided initData after creation.\n    ///\n    /// Emits AccountCreated event.\n    ///", "metadata": {"page_number": 5, "source": "data/erc6551_docs.pdf"}}
{"id": "3d3e77a15c11", "text": "/// provided initData after creation.\n    ///\n    /// Emits AccountCreated event.\n    ///\n    /// @return the address of the account\n    function  createAccount (\n        address implementation ,\n        uint256 chainId,\n        address tokenContract ,\n        uint256 tokenId,\n        uint256 salt,\n        bytes calldata  initData\n    ) external  returns (address);\n    /// @dev Returns the computed address of a token bound account\n    ///\n    /// @return The computed address of the account\n    function  account(\n        address implementation ,\n        uint256 chainId,\n        address tokenContract ,\n        uint256 tokenId,\n        uint256 salt\n    ) external  view returns (address);\n}\n Account Interface", "metadata": {"page_number": 5, "source": "data/erc6551_docs.pdf"}}
{"id": "3d40324b37e9", "text": "uint256 chainId,\n        address tokenContract ,\n        uint256 tokenId,\n        uint256 salt\n    ) external  view returns (address);\n}\n Account Interface\nAll token bound accounts SHOULD be created via the registry.\nAll token bound account implementations MUST implement ERC-165 interface detection.\nAll token bound account implementations MUST implement ERC-1271 signature validation.", "metadata": {"page_number": 5, "source": "data/erc6551_docs.pdf"}}
{"id": "9a263b5fad04", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 6/13All token bound account implementations MUST implement the following interface:\n/// @dev the ERC-165 identifier for this interface is `0x400a0398`\ninterface  IERC6551Account  {\n    /// @dev Token bound accounts MUST implement a `receive` function.\n    ///\n    /// Token bound accounts MAY perform arbitrary logic to restrict conditions\n    /// under which Ether can be received.\n    receive() external  payable;\n    /// @dev Executes `call` on address `to`, with value `value` and calldata\n    /// `data`.\n    ///\n    /// MUST revert and bubble up errors if call fails.\n    ///", "metadata": {"page_number": 6, "source": "data/erc6551_docs.pdf"}}
{"id": "4f1e42fbfc04", "text": "/// `data`.\n    ///\n    /// MUST revert and bubble up errors if call fails.\n    ///\n    /// By default, token bound accounts MUST allow the owner of the ERC-721 tok\n    /// which owns the account to execute arbitrary calls using `executeCall`.\n    ///\n    /// Token bound accounts MAY implement additional authorization mechanisms\n    /// which limit the ability of the ERC-721 token holder to execute calls.\n    ///\n    /// Token bound accounts MAY implement additional execution functions which\n    /// grant execution permissions to other non-owner accounts.\n    ///\n    /// @return The result of the call\n    function  executeCall (\n        address to,\n        uint256 value,\n        bytes calldata  data\n    ) external  payable returns (bytes memory);", "metadata": {"page_number": 6, "source": "data/erc6551_docs.pdf"}}
{"id": "20ffa14116cf", "text": "/// @return The result of the call\n    function  executeCall (\n        address to,\n        uint256 value,\n        bytes calldata  data\n    ) external  payable returns (bytes memory);\n    /// @dev Returns identifier of the ERC-721 token which owns the\n    /// account\n    ///\n    /// The return value of this function MUST be constant - it MUST NOT change\n    /// over time.\n    ///\n    /// @return chainId The EIP-155 ID of the chain the ERC-721 token exists on\n    /// @return tokenContract The contract address of the ERC-721 token\n    /// @return tokenId The ID of the ERC-721 token\n    function  token()\n        external\n        view\n        returns (\n            uint256 chainId,", "metadata": {"page_number": 6, "source": "data/erc6551_docs.pdf"}}
{"id": "4cff0942db24", "text": "/// @return tokenId The ID of the ERC-721 token\n    function  token()\n        external\n        view\n        returns (\n            uint256 chainId,\n            address tokenContract ,", "metadata": {"page_number": 6, "source": "data/erc6551_docs.pdf"}}
{"id": "9a1b08f664c9", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 7/13            uint256 tokenId\n        );\n    /// @dev Returns the owner of the ERC-721 token which controls the account\n    /// if the token exists.\n    ///\n    /// This is value is obtained by calling `ownerOf` on the ERC-721 contract.\n    ///\n    /// @return Address of the owner of the ERC-721 token which owns the account\n    function  owner() external  view returns (address);\n    /// @dev Returns a nonce value that is updated on every successful transacti\n    ///\n    /// @return The current account nonce\n    function  nonce() external  view returns (uint256);\n}", "metadata": {"page_number": 7, "source": "data/erc6551_docs.pdf"}}
{"id": "3a984cccae25", "text": "///\n    /// @return The current account nonce\n    function  nonce() external  view returns (uint256);\n}\n Rationale\n Counterfactual Account Addresses\nBy specifying a canonical account registry, applications wishing to support this proposal can\ncompute the address for a given token bound account using a certain implementation prior to\nthe deployment of the contract for that account. This allows assets to be sent securely to the\nowner of a token without needing to know the owner\u02bcs address. A canonical registry also\nallows client side applications to query for assets owned by a token from a single entry point.\n Account Ambiguity\nThe specification proposed above allows ERC-721 tokens to have multiple token bound\naccounts, one per implementation address. During the development of this proposal,\nalternative architectures were considered which would have assigned a single token bound\naccount to each ERC-721 token, making each token bound account address an unambiguous", "metadata": {"page_number": 7, "source": "data/erc6551_docs.pdf"}}
{"id": "ff22bb0bb695", "text": "accounts, one per implementation address. During the development of this proposal,\nalternative architectures were considered which would have assigned a single token bound\naccount to each ERC-721 token, making each token bound account address an unambiguous\nidentifier.\nHowever, these alternatives present several trade offs.\nFirst, due to the permissionless nature of smart contracts, it is impossible to enforce a limit of\none token bound account per ERC-721 token. Anyone wishing to utilize multiple token bound\naccounts per ERC-721 token could do so by deploying an additional registry contract.\nSecond, limiting each ERC-721 token to a single token bound account would require a static,\ntrusted account implementation to be included in this proposal. This implementation would\ninevitably impose specific constraints on the capabilities of token bound accounts. Given the\nnumber of unexplored use cases this proposal enables and the benefit that diverse account", "metadata": {"page_number": 7, "source": "data/erc6551_docs.pdf"}}
{"id": "5e0acb03a57b", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 8/13implementations could bring to the non-fungible token ecosystem, it is the authors\u02bc opinion\nthat defining a canonical and constrained implementation in this proposal is premature.\nFinally, this proposal seeks to grant ERC-721 tokens the ability to act as agents on-chain. In\ncurrent practice, on-chain agents often utilize multiple accounts. A common example is\nindividuals who use a \u201chot\u201d account for daily use and a \u201ccold\u201d account for storing valuables. If\non-chain agents commonly use multiple accounts, it stands to reason that ERC-721 tokens\nought to inherit the same ability.\n Proxy Implementation\nERC-1167 minimal proxies are well supported by existing infrastructure and are a common\nsmart contract pattern. This proposal deploys each token bound account using a custom", "metadata": {"page_number": 8, "source": "data/erc6551_docs.pdf"}}
{"id": "428ceaccb964", "text": "ought to inherit the same ability.\n Proxy Implementation\nERC-1167 minimal proxies are well supported by existing infrastructure and are a common\nsmart contract pattern. This proposal deploys each token bound account using a custom\nERC-1167 proxy implementation that stores the salt, implementation address, chain id, token\ncontract address, and token ID as ABI-encoded constant data appended to the contract\nbytecode. This allows token bound account implementations to easily query this data while\nensuring it remains constant. This approach was taken to maximize compatibility with existing\ninfrastructure while also giving smart contract developers full flexibility when creating custom\ntoken bound account implementations.\n EIP-155 Support\nThis proposal uses EIP-155 chain IDs to identify ERC-721 tokens along with their contract\naddress and token ID. ERC-721 token identifiers are globally unique on a single Ethereum\nchain, but may not be unique across multiple Ethereum chains. Using chain IDs to uniquely", "metadata": {"page_number": 8, "source": "data/erc6551_docs.pdf"}}
{"id": "78a629bdeb3e", "text": "address and token ID. ERC-721 token identifiers are globally unique on a single Ethereum\nchain, but may not be unique across multiple Ethereum chains. Using chain IDs to uniquely\nidentify ERC-721 tokens allows smart contract authors wishing to implement this proposal to\noptionally support multi-chain token bound accounts.\n Backwards Compatibility\nThis proposal seeks to be maximally backwards compatible with existing non-fungible token\ncontracts. As such, it does not extend the ERC-721 standard.\nAdditionally, this proposal does not require the registry to perform an ERC-165 interface\ncheck for ERC-721 compatibility prior to account creation. This is by design in order to\nmaximize backwards compatibility with non-fungible token contracts that pre-date the ERC-\n721 standard, such as Cryptokitties. Smart contract authors implementing this proposal may\noptionally choose to enforce interface detection for ERC-721.", "metadata": {"page_number": 8, "source": "data/erc6551_docs.pdf"}}
{"id": "a244e859da33", "text": "maximize backwards compatibility with non-fungible token contracts that pre-date the ERC-\n721 standard, such as Cryptokitties. Smart contract authors implementing this proposal may\noptionally choose to enforce interface detection for ERC-721.\nNon-fungible token contracts that do not implement an ownerOf method, such as\nCryptopunks, are not compatible with this proposal. The system outlined in this proposal\ncould be used to support such collections with minor modifications, but that is outside the\nscope of this proposal.", "metadata": {"page_number": 8, "source": "data/erc6551_docs.pdf"}}
{"id": "57024e2ea9a4", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 9/13 Reference Implementation\n Example Account Implementation\npragma solidity  ^0.8.13;\nimport \"openzeppelin-contracts/utils/introspection/IERC165.sol\" ;\nimport \"openzeppelin-contracts/token/ERC721/IERC721.sol\" ;\nimport \"openzeppelin-contracts/interfaces/IERC1271.sol\" ;\nimport \"openzeppelin-contracts/utils/cryptography/SignatureChecker.sol\" ;\nimport \"sstore2/utils/Bytecode.sol\" ;\ncontract  ExampleERC6551Account  is IERC165, IERC1271 , IERC6551Account  {\n    receive() external  payable {}", "metadata": {"page_number": 9, "source": "data/erc6551_docs.pdf"}}
{"id": "7da4fba971fe", "text": "import \"sstore2/utils/Bytecode.sol\" ;\ncontract  ExampleERC6551Account  is IERC165, IERC1271 , IERC6551Account  {\n    receive() external  payable {}\n    function  executeCall (\n        address to,\n        uint256 value,\n        bytes calldata  data\n    ) external  payable returns (bytes memory result) {\n        require(msg.sender == owner(), \"Not token owner\" );\n        bool success;\n        (success, result) = to.call{value: value}(data);\n        if (!success) {\n            assembly  {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    function  token()\n        external\n        view\n        returns (\n            uint256 chainId,", "metadata": {"page_number": 9, "source": "data/erc6551_docs.pdf"}}
{"id": "a623e933a6ae", "text": "}\n        }\n    }\n    function  token()\n        external\n        view\n        returns (\n            uint256 chainId,\n            address tokenContract ,\n            uint256 tokenId\n        )\n    {\n        uint256 length = address(this).code.length\n        return\n            abi.decode(\n                Bytecode .codeAt(address(this), length - 0x60, length),\n                (uint256, address, uint256)", "metadata": {"page_number": 9, "source": "data/erc6551_docs.pdf"}}
{"id": "0ad738dcecda", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 10/13            );\n    }\n    function  owner() public view returns (address) {\n        (uint256 chainId, address tokenContract , uint256 tokenId) = this\n            .token();\n        if (chainId != block.chainid) return address(0);\n        return IERC721(tokenContract ).ownerOf(tokenId);\n    }\n    function  supportsInterface (bytes4 interfaceId ) public pure returns (bool) {\n        return (interfaceId  == type(IERC165).interfaceId  ||\n            interfaceId  == type(IERC6551Account ).interfaceId );\n    }\n    function  isValidSignature (bytes32 hash, bytes memory signature )", "metadata": {"page_number": 10, "source": "data/erc6551_docs.pdf"}}
{"id": "3bf6a944310c", "text": "interfaceId  == type(IERC6551Account ).interfaceId );\n    }\n    function  isValidSignature (bytes32 hash, bytes memory signature )\n        external\n        view\n        returns (bytes4 magicValue )\n    {\n        bool isValid = SignatureChecker .isValidSignatureNow (\n            owner(),\n            hash,\n            signature\n        );\n        if (isValid) {\n            return IERC1271 .isValidSignature .selector ;\n        }\n        return \"\";\n    }\n}\n Registry Implementation\npragma solidity  ^0.8.13;\nimport \"openzeppelin-contracts/utils/Create2.sol\" ;\ncontract  ERC6551Registry  is IERC6551Registry  {\n    error InitializationFailed ();", "metadata": {"page_number": 10, "source": "data/erc6551_docs.pdf"}}
{"id": "c5c6287bdf67", "text": "import \"openzeppelin-contracts/utils/Create2.sol\" ;\ncontract  ERC6551Registry  is IERC6551Registry  {\n    error InitializationFailed ();\n    function  createAccount (\n        address implementation ,\n        uint256 chainId,", "metadata": {"page_number": 10, "source": "data/erc6551_docs.pdf"}}
{"id": "0cdf74f41bae", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 11/13        address tokenContract ,\n        uint256 tokenId,\n        uint256 salt,\n        bytes calldata  initData\n    ) external  returns (address) {\n        bytes memory code = _creationCode (implementation , chainId, tokenContract\n        address _account  = Create2.computeAddress (\n            bytes32(salt),\n            keccak256 (code)\n        );\n        if (_account .code.length != 0) return _account ;\n        _account  = Create2.deploy(0, bytes32(salt), code);\n        if (initData .length != 0) {\n            (bool success, ) = _account .call(initData );", "metadata": {"page_number": 11, "source": "data/erc6551_docs.pdf"}}
{"id": "a4a8aaa5dd52", "text": "_account  = Create2.deploy(0, bytes32(salt), code);\n        if (initData .length != 0) {\n            (bool success, ) = _account .call(initData );\n            if (!success) revert InitializationFailed ();\n        }\n        emit AccountCreated (\n            _account ,\n            implementation ,\n            chainId,\n            tokenContract ,\n            tokenId,\n            salt\n        );\n        return _account ;\n    }\n    function  account(\n        address implementation ,\n        uint256 chainId,\n        address tokenContract ,\n        uint256 tokenId,\n        uint256 salt\n    ) external  view returns (address) {\n        bytes32 bytecodeHash  = keccak256 (", "metadata": {"page_number": 11, "source": "data/erc6551_docs.pdf"}}
{"id": "3cfa674e7631", "text": "address tokenContract ,\n        uint256 tokenId,\n        uint256 salt\n    ) external  view returns (address) {\n        bytes32 bytecodeHash  = keccak256 (\n            _creationCode (implementation , chainId, tokenContract , tokenId, salt\n        );\n        return Create2.computeAddress (bytes32(salt), bytecodeHash );\n    }", "metadata": {"page_number": 11, "source": "data/erc6551_docs.pdf"}}
{"id": "ff806ed1106e", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 12/13    function  _creationCode (\n        address implementation_ ,\n        uint256 chainId_ ,\n        address tokenContract_ ,\n        uint256 tokenId_ ,\n        uint256 salt_\n    ) internal  pure returns (bytes memory) {\n        return\n            abi.encodePacked (\n                hex\"3d60ad80600a3d3981f3363d3d373d3d3d363d73\" ,\n                implementation_ ,\n                hex\"5af43d82803e903d91602b57fd5bf3\" ,\n                abi.encode(salt_, chainId_ , tokenContract_ , tokenId_ )\n            );\n    }", "metadata": {"page_number": 12, "source": "data/erc6551_docs.pdf"}}
{"id": "68d1d9c8842e", "text": "abi.encode(salt_, chainId_ , tokenContract_ , tokenId_ )\n            );\n    }\n}\n Security Considerations\n Fraud Prevention\nIn order to enable trustless sales of token bound accounts, decentralized marketplaces will\nneed to implement safeguards against fraudulent behavior by malicious account owners.\nConsider the following potential scam:\nAlice owns an ERC-721 token X, which owns token bound account Y.\nAlice deposits 10ETH into account Y\nBob offers to purchase token X for 11ETH via a decentralized marketplace, assuming\nhe will receive the 10ETH stored in account Y along with the token\nAlice withdraws 10ETH from the token bound account, and immediately accepts\nBob\u02bcs offer\nBob receives token X, but account Y is empty\nTo mitigate fraudulent behavior by malicious account owners, decentralized marketplaces\nSHOULD implement protection against these sorts of scams at the marketplace level.", "metadata": {"page_number": 12, "source": "data/erc6551_docs.pdf"}}
{"id": "6956104f8962", "text": "Bob\u02bcs offer\nBob receives token X, but account Y is empty\nTo mitigate fraudulent behavior by malicious account owners, decentralized marketplaces\nSHOULD implement protection against these sorts of scams at the marketplace level.\nContracts which implement this EIP MAY also implement certain protections against\nfraudulent behavior.\nHere are a few mitigations strategies to be considered:\nAttach the current token bound account nonce to the marketplace order. If the nonce\nof the account has changed since the order was placed, consider the offer void. This\nfunctionality would need to be supported at the marketplace level.", "metadata": {"page_number": 12, "source": "data/erc6551_docs.pdf"}}
{"id": "6562f5dcd9d6", "text": "6/25/23, 12:24 AM ERC-6551: Non-fungible Token Bound Accounts\nhttps://eips.ethereum.or g/EIPS/eip-6551 13/13Attach a list of asset commitments to the marketplace order that are expected to\nremain in the token bound account when the order is fulfilled. If any of the committed\nassets have been removed from the account since the order was placed, consider the\noffer void. This would also need to be implemented by the marketplace.\nSubmit the order to the decentralized market via an external smart contract which\nperforms the above logic before validating the order signature. This allows for safe\ntransfers to be implemented without marketplace support.\nImplement a locking mechanism on the token bound account implementation that\nprevents malicious owners from extracting assets from the account while locked\nPreventing fraud is outside the scope of this proposal.\n Ownership Cycles\nAll assets held in an token bound account may be rendered inaccessible if an ownership cycle", "metadata": {"page_number": 13, "source": "data/erc6551_docs.pdf"}}
{"id": "292ec9b1340d", "text": "prevents malicious owners from extracting assets from the account while locked\nPreventing fraud is outside the scope of this proposal.\n Ownership Cycles\nAll assets held in an token bound account may be rendered inaccessible if an ownership cycle\nis created. The simplest example is the case of an ERC-721 token being transferred to it\u02bcs own\ntoken bound account. If this occurs, both the ERC-721 token and all of the assets stored in the\ntoken bound account would be permanently inaccessible, since the token bound account is\nincapable of executing a transaction which transfers the ERC-721 token.\nOwnership cycles can be introduced in any graph of n>0 token bound accounts. On-chain\nprevention of these cycles is difficult to enforce given the infinite search space required, and\nas such is outside the scope of this proposal. Application clients and account implementations\nwishing to adopt this proposal are encouraged to implement measures that limit the possibility\nof ownership cycles.\n Copyright\nCopyright and related rights waived via CC0.", "metadata": {"page_number": 13, "source": "data/erc6551_docs.pdf"}}
{"id": "dea9cb8e4a3c", "text": "as such is outside the scope of this proposal. Application clients and account implementations\nwishing to adopt this proposal are encouraged to implement measures that limit the possibility\nof ownership cycles.\n Copyright\nCopyright and related rights waived via CC0.\nCitation\nPlease cite this document as:\nJayden Windle\u00a0(@jaydenwindle), Benny Giang\u00a0<bg@futureprimitive.xyz>, Steve Jang, Druzy\nDowns\u00a0(@druzydowns), Raymond Huynh\u00a0(@huynhr), Alanah\nLam\u00a0<alanah@futureprimitive.xyz>, Wilkins Chung (@wwhchung)\u00a0<wilkins@manifold.xyz>,\nPaul Sullivan (@sullivph)\u00a0<paul.sullivan@manifold.xyz>, \"ERC-6551: Non-fungible Token\nBound Accounts [DRAFT],\" Ethereum Improvement Proposals, no. 6551, February 2023.", "metadata": {"page_number": 13, "source": "data/erc6551_docs.pdf"}}
{"id": "55fe806abdc5", "text": "Paul Sullivan (@sullivph)\u00a0<paul.sullivan@manifold.xyz>, \"ERC-6551: Non-fungible Token\nBound Accounts [DRAFT],\" Ethereum Improvement Proposals, no. 6551, February 2023.\n[Online serial]. Available: https://eips.ethereum.org/EIPS/eip-6551.", "metadata": {"page_number": 13, "source": "data/erc6551_docs.pdf"}}
